<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>SportsStatsX Admin</title>
  <style>
    body { font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif; margin: 18px; }
    .top { display:flex; justify-content:space-between; align-items:flex-end; gap:12px; flex-wrap:wrap; }
    .muted { color:#666; font-size:12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    .card { border:1px solid #ddd; border-radius:10px; padding:14px; }
    .card h2 { margin:0 0 10px 0; font-size: 16px; }
    input, textarea, button, select { font-size: 14px; }
    input, textarea, select {
      width: 100%; box-sizing:border-box; padding:10px; border-radius:8px; border:1px solid #ccc;
      background:#fff;
    }
    textarea { min-height: 140px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    button { padding:10px 12px; border-radius:8px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    button.primary { border-color:#000; }
    button.danger { border-color:#d33; color:#d33; }
    button.soft { opacity:0.9; }
    .grid { display:grid; grid-template-columns: 1.1fr 0.9fr; gap:12px; align-items:start; }
    @media (max-width: 1100px) { .grid { grid-template-columns: 1fr; } }

    .listWrap { max-height: 560px; overflow:auto; border:1px solid #eee; border-radius:10px; }
    .item {
      padding:10px 12px; border-bottom:1px solid #f0f0f0; cursor:pointer;
      display:flex; gap:10px; align-items:flex-start;
    }
    .item:hover { background:#fafafa; }
    .item.sel { background:#f3f6ff; }
    .badge { display:inline-block; padding:2px 8px; border:1px solid #ddd; border-radius:999px; font-size:12px; }
    .item.hidden { opacity: 0.55; }
    .badge.ovr { border-color:#000; }
    .badge.hid { border-color:#d33; color:#d33; }
    .right { margin-left:auto; text-align:right; }
    .small { font-size:12px; }
    .k { font-weight:600; }
    .ok { color:#0a7; }
    .bad { color:#d33; }

    pre {
      margin:0; padding:10px; background:#fafafa; border:1px solid #eee; border-radius:10px;
      max-height: 260px; overflow:auto;
    }

    .tabs { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .tabbtn { padding:8px 10px; border-radius:999px; border:1px solid #ddd; background:#fff; cursor:pointer; font-size:12px; }
    .tabbtn.active { border-color:#000; }
    .tabpane { display:none; margin-top:10px; }
    .tabpane.active { display:block; }

    table { width:100%; border-collapse:collapse; }
    th, td { border-bottom:1px solid #eee; padding:8px; text-align:left; vertical-align:top; }
  </style>
</head>
<body>
  <div class="top">
    <div>
      <h1 style="margin:0 0 6px 0;">SportsStatsX Admin</h1>
      <div class="muted">
        경로: <span id="adminPathText" class="mono"></span> · API 헤더: <span class="mono">X-Admin-Token</span> 필요
        · <button class="soft" style="padding:6px 10px;" onclick="logoutToken()">토큰 삭제(로그아웃)</button>
      </div>
    </div>
    <div class="muted" id="statusLine"></div>
  </div>

  <div class="grid" style="margin-top:14px;">
    <!-- LEFT: Fixtures browser -->
    <div class="card">
      <h2>Fixtures Browser</h2>

      <div class="row">
        <div style="min-width:190px; flex: 0 0 190px;">
          <label class="muted">Date</label>
          <input id="fxDate" type="date"/>
        </div>

        <div style="min-width:220px; flex: 1 1 220px;">
          <label class="muted">Timezone</label>
          <select id="fxTz">
            <option value="Asia/Seoul">Asia/Seoul</option>
            <option value="UTC">UTC</option>
            <option value="Europe/London">Europe/London</option>
            <option value="America/New_York">America/New_York</option>
            <option value="America/Los_Angeles">America/Los_Angeles</option>
          </select>
        </div>

        <div style="min-width:260px; flex: 1 1 260px;">
          <label class="muted">League IDs (comma, optional)</label>
          <input id="fxLeagueIds" placeholder="예: 39,140,78"/>
        </div>

        <div style="min-width:220px; flex: 1 1 220px;">
          <label class="muted">Search (team/league)</label>
          <input id="fxSearch" placeholder="예: Arsenal / LaLiga"/>
        </div>

        <div style="min-width:140px; flex: 0 0 140px; align-self:flex-end;">
          <button class="primary" style="width:100%;" onclick="loadFixtures()">불러오기</button>
        </div>
      </div>

      <div class="muted" style="margin-top:10px;" id="fxHint"></div>

      <div class="listWrap" style="margin-top:10px;">
        <div id="fxList"></div>
      </div>

      <div class="tabs">
        <button class="tabbtn active" id="tab_now_btn" onclick="showTab('now')">현재(노출)</button>
        <button class="tabbtn" id="tab_raw_btn" onclick="showTab('raw')">원본(raw)</button>
        <button class="tabbtn" id="tab_patch_btn" onclick="showTab('patch')">override patch</button>
        <button class="tabbtn" id="tab_diff_btn" onclick="showTab('diff')">diff</button>
        <button class="tabbtn" id="tab_bundle_raw_btn" onclick="showTab('bundle_raw')">bundle(raw)</button>
        <button class="tabbtn" id="tab_bundle_merged_btn" onclick="showTab('bundle_merged')">bundle(merged)</button>
        <button class="tabbtn" id="tab_bundle_diff_btn" onclick="showTab('bundle_diff')">bundle diff</button>
      </div>

      <div class="tabpane active" id="tab_now">
        <div class="muted">선택된 경기(override 반영 결과)</div>
        <pre class="mono" id="fxPreviewNow">{}</pre>
      </div>

      <div class="tabpane" id="tab_raw">
        <div class="muted">선택된 경기(override 미적용 원본)</div>
        <pre class="mono" id="fxPreviewRaw">{}</pre>
        <div class="muted" style="margin-top:8px;" id="rawHint"></div>
      </div>

      <div class="tabpane" id="tab_patch">
        <div class="muted">현재 override patch</div>
        <pre class="mono" id="fxPreviewPatch">{}</pre>
      </div>

      <div class="tabpane" id="tab_diff">
        <div class="muted">원본(raw) → 현재(노출) 변경 요약</div>
        <pre class="mono" id="fxPreviewDiff">[]</pre>
      </div>

      <div class="tabpane" id="tab_bundle_raw">
        <div class="muted">선택된 경기(bundle 원본: override 미적용)</div>
        <pre class="mono" id="bundlePreviewRaw">{}</pre>
      </div>

      <div class="tabpane" id="tab_bundle_merged">
        <div class="muted">선택된 경기(bundle merged: override 적용)</div>
        <pre class="mono" id="bundlePreviewMerged">{}</pre>
      </div>

      <div class="tabpane" id="tab_bundle_diff">
        <div class="muted">bundle(raw) → bundle(merged) 변경 요약</div>
        <pre class="mono" id="bundlePreviewDiff">[]</pre>
      </div>
      
    </div>

    <!-- RIGHT: Editor + logs -->
    <div class="row" style="align-items:stretch;">
      <div class="card" style="flex: 1 1 520px;">
        <h2>Override Editor</h2>

        <div class="row">
          <div style="flex: 1 1 220px;">
            <label class="muted">Fixture ID</label>
            <input id="fixtureId" placeholder="예: 123456"/>
          </div>
          <div style="flex: 1 1 220px;">
            <label class="muted">Quick actions</label>
            <div class="row" style="gap:8px;">
              <button onclick="getOverride()">조회</button>
              <button class="danger" onclick="deleteOverride()">삭제(원복)</button>
              <button onclick="hideFixture()">숨김(hidden=true)</button>
              <button onclick="unhideFixture()">숨김해제(hidden=false)</button>
            </div>
          </div>
        </div>

        <div style="margin-top:10px;" class="muted">Quick Edit → Patch 생성</div>
        <div class="row">
          <div style="flex:1 1 220px;">
            <label class="muted">Venue</label>
            <input id="qeVenue" placeholder="venue_name"/>
          </div>
          <div style="flex:1 1 220px;">
            <label class="muted">League Round</label>
            <input id="qeRound" placeholder="league_round"/>
          </div>
        </div>

        <div class="row">
          <div style="flex:1 1 220px;">
            <label class="muted">Status Long</label>
            <input id="qeStatusLong" placeholder="status_long"/>
          </div>
          <div style="flex:1 1 220px;">
            <label class="muted">Elapsed</label>
            <input id="qeElapsed" type="number" placeholder="elapsed (ex: 57)"/>
          </div>
        </div>

        <div class="row">
          <div style="flex:1 1 220px;">
            <label class="muted">Home FT</label>
            <input id="qeHomeFt" type="number" placeholder="home.ft"/>
          </div>
          <div style="flex:1 1 220px;">
            <label class="muted">Away FT</label>
            <input id="qeAwayFt" type="number" placeholder="away.ft"/>
          </div>
        </div>

        <div class="row">
          <div style="flex:1 1 220px;">
            <label class="muted">Home HT</label>
            <input id="qeHomeHt" type="number" placeholder="home.ht"/>
          </div>
          <div style="flex:1 1 220px;">
            <label class="muted">Away HT</label>
            <input id="qeAwayHt" type="number" placeholder="away.ht"/>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="primary" onclick="applyQuickEditToPatch()">Quick Edit → Patch JSON 반영</button>
          <button onclick="upsertOverride()">저장(Upsert)</button>
        </div>

        <div style="height:10px;"></div>
        <label class="muted">Patch JSON (부분만)</label>
        <textarea id="patch" placeholder='예: { "venue_name": "Edited", "home": { "ft": 2 } }'></textarea>

        <div id="ovResult" class="muted" style="margin-top:10px;"></div>
      </div>

      <div class="card" style="flex: 1 1 520px;">
        <h2>Admin Logs</h2>
        <div class="row">
          <input id="logFixture" placeholder="fixture_id 필터(선택)"/>
          <select id="logEvent" style="min-width:160px;">
            <option value="">event_type 전체</option>
            <option value="access">access</option>
            <option value="auth_fail">auth_fail</option>
            <option value="override_get">override_get</option>
            <option value="override_upsert">override_upsert</option>
            <option value="override_delete">override_delete</option>
            <option value="logs_list">logs_list</option>
            <option value="fixtures_raw_list">fixtures_raw_list</option>
            <option value="fixtures_merged_list">fixtures_merged_list</option>
          </select>
          <button onclick="loadLogs()">새로고침</button>
        </div>

        <div style="height:10px;"></div>
        <table>
          <thead>
            <tr>
              <th style="width:160px;">ts</th>
              <th style="width:140px;">type</th>
              <th style="width:80px;">ok</th>
              <th>detail</th>
            </tr>
          </thead>
          <tbody id="logsBody"></tbody>
        </table>
        <div id="logHint" class="muted" style="margin-top:10px;"></div>
      </div>
    </div>
  </div>

<script>
  const adminPath = (location.pathname || "").replace(/^\/+/, "").split("/")[0] || "";
  document.getElementById("adminPathText").textContent = "/" + adminPath;

  const tokenKey = "SSX_ADMIN_TOKEN";
  let selectedFixture = null;

  let bundleRaw = null;
  let bundleMerged = null;


  // 현재(노출) fixtures
  let currentFixtures = [];

  // 원본(raw) fixtures 캐시: 같은 필터(date/tz/league_ids) 기준으로 한 번만 가져오기
  let rawCacheKey = "";
  let rawFixturesMap = null;

  function setStatusLine(msg) {
    document.getElementById("statusLine").textContent = msg || "";
  }

  function logoutToken() {
    localStorage.removeItem(tokenKey);
    alert("토큰을 삭제했습니다. 다음 admin API 호출 시 다시 입력합니다.");
  }

  function adminHeaders() {
    const t = localStorage.getItem(tokenKey) || "";
    return {
      "Content-Type": "application/json",
      "X-Admin-Token": t,
    };
  }

  function ensureToken() {
    let t = localStorage.getItem(tokenKey);
    if (!t) {
      t = prompt("관리자 토큰(ADMIN_TOKEN)을 입력하세요");
      if (t) localStorage.setItem(tokenKey, t);
    }
    return t;
  }

  function adminUrl(path) {
    return "/" + adminPath + path;
  }

  async function api(path, opt={}) {
    ensureToken();
    const res = await fetch(path, {
      ...opt,
      headers: { ...(opt.headers||{}), ...adminHeaders() },
    });
    const txt = await res.text();
    let data = null;
    try { data = JSON.parse(txt); } catch (e) { data = { raw: txt }; }
    return { status: res.status, data };
  }

  async function publicApi(path) {
    const res = await fetch(path);
    const txt = await res.text();
    let data = null;
    try { data = JSON.parse(txt); } catch (e) { data = { raw: txt }; }
    return { status: res.status, data };
  }

  function setOv(msg, ok=true) {
    const el = document.getElementById("ovResult");
    el.innerHTML = ok ? `<span class="ok">${msg}</span>` : `<span class="bad">${msg}</span>`;
  }

  function safeNum(v) {
    if (v === "" || v === null || v === undefined) return null;
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }

  function deepMerge(base, patch) {
    if (base && typeof base === "object" && !Array.isArray(base) &&
        patch && typeof patch === "object" && !Array.isArray(patch)) {
      const out = { ...base };
      for (const k of Object.keys(patch)) {
        out[k] = deepMerge(out[k], patch[k]);
      }
      return out;
    }
    return patch;
  }

  function isoDateLocal() {
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2, "0");
    const dd = String(d.getDate()).padStart(2, "0");
    return `${yyyy}-${mm}-${dd}`;
  }

  function fmtInTz(dateUtcStr, tz) {
    try {
      const d = new Date(dateUtcStr);
      return d.toLocaleString("sv-SE", { timeZone: tz, hour12: false }).replace(" ", " ");
    } catch (e) {
      return dateUtcStr || "";
    }
  }

  function statusOrderKey(sg) {
    const v = (sg || "").toUpperCase();
    if (v.includes("LIVE")) return 0;
    if (v === "NS") return 1;
    if (v.includes("1H") || v.includes("2H") || v.includes("HT")) return 2;
    if (v.includes("FT") || v.includes("FINISHED")) return 9;
    return 5;
  }


  function showTab(name) {
    const names = ["now","raw","patch","diff","bundle_raw","bundle_merged","bundle_diff"];
    for (const n of names) {
      const pane = document.getElementById("tab_" + n);
      const btn = document.getElementById("tab_" + n + "_btn");
      if (pane) pane.classList.toggle("active", n === name);
      if (btn) btn.classList.toggle("active", n === name);
    }
  }


  function renderFixtures() {
    const list = document.getElementById("fxList");
    list.innerHTML = "";

    const q = (document.getElementById("fxSearch").value || "").trim().toLowerCase();

    const filtered = currentFixtures.filter(f => {
      if (!q) return true;
      const s = [
        f.league_name, f.league_country, f.league_round,
        f.home?.name, f.away?.name,
        String(f.fixture_id || "")
      ].join(" ").toLowerCase();
      return s.includes(q);
    });

    filtered.sort((a,b) => {
      const ka = statusOrderKey(a.status_group);
      const kb = statusOrderKey(b.status_group);
      if (ka !== kb) return ka - kb;
      return String(a.date_utc||"").localeCompare(String(b.date_utc||""));
    });

    for (const f of filtered) {
      const div = document.createElement("div");
      const isHidden = (f.hidden === true);
      div.className =
        "item" +
        ((selectedFixture && selectedFixture.fixture_id === f.fixture_id) ? " sel" : "") +
        (isHidden ? " hidden" : "");

      div.onclick = () => selectFixture(f.fixture_id);

      const tz = document.getElementById("fxTz").value || "UTC";
      const when = fmtInTz(f.date_utc, tz);

      const score = `${f.home?.ft ?? "-"} : ${f.away?.ft ?? "-"}`;
      const ht = `${f.home?.ht ?? "-"} : ${f.away?.ht ?? "-"}`;

      const isOvr = (f._has_override === true);
      const badges = [
        `<span class="badge mono">${(f.status_group||"").toUpperCase()}</span>`,
        isOvr ? `<span class="badge mono ovr">OVR</span>` : ``,
        isHidden ? `<span class="badge mono hid">HIDDEN</span>` : ``,
      ].filter(Boolean).join(" ");

      div.innerHTML = `
        <div>
          <div class="small muted mono">${when}</div>
          <div class="k">${f.home?.name || "HOME"} <span class="muted">vs</span> ${f.away?.name || "AWAY"}</div>
          <div class="small muted">${f.league_name || ""} · ${f.league_round || ""}</div>
        </div>
        <div class="right">
          <div style="display:flex; gap:6px; justify-content:flex-end; flex-wrap:wrap;">${badges}</div>
          <div class="mono" style="margin-top:6px;">${score}</div>
          <div class="small muted mono">HT ${ht}</div>
        </div>
      `;

      list.appendChild(div);
    }

    document.getElementById("fxHint").textContent =
      `rows: ${filtered.length} / ${currentFixtures.length} · 클릭하면 원본/현재/차이까지 비교됩니다`;
  }

  function fillQuickEditFromFixture(f) {
    document.getElementById("qeVenue").value = f.venue_name ?? "";
    document.getElementById("qeRound").value = f.league_round ?? "";
    document.getElementById("qeStatusLong").value = f.status_long ?? "";
    document.getElementById("qeElapsed").value = (f.elapsed ?? "") === null ? "" : (f.elapsed ?? "");

    document.getElementById("qeHomeFt").value = (f.home?.ft ?? "") === null ? "" : (f.home?.ft ?? "");
    document.getElementById("qeAwayFt").value = (f.away?.ft ?? "") === null ? "" : (f.away?.ft ?? "");
    document.getElementById("qeHomeHt").value = (f.home?.ht ?? "") === null ? "" : (f.home?.ht ?? "");
    document.getElementById("qeAwayHt").value = (f.away?.ht ?? "") === null ? "" : (f.away?.ht ?? "");
  }

  function getFilterKey() {
    const date = document.getElementById("fxDate").value || "";
    const tz = document.getElementById("fxTz").value || "UTC";
    const leagueIds = (document.getElementById("fxLeagueIds").value || "").trim();
    return `${date}__${tz}__${leagueIds}`;
  }

  function buildFixturesQuery() {
    const date = document.getElementById("fxDate").value;
    const tz = document.getElementById("fxTz").value || "UTC";
    const leagueIds = (document.getElementById("fxLeagueIds").value || "").trim();

    const qs = new URLSearchParams();
    qs.set("date", date);
    qs.set("timezone", tz);
    if (leagueIds) qs.set("league_ids", leagueIds);
    return qs;
  }

  async function ensureRawLoaded() {
    const key = getFilterKey();
    if (rawFixturesMap && rawCacheKey === key) return true;

    rawFixturesMap = null;
    rawCacheKey = key;

    const qs = buildFixturesQuery();
    document.getElementById("rawHint").textContent = "원본(raw) 불러오는 중...";
    const r = await api(adminUrl(`/api/fixtures_raw?` + qs.toString()), { method: "GET" });

    if (r.status >= 400 || !r.data || !r.data.ok) {
      document.getElementById("rawHint").textContent = "원본(raw) 로드 실패: " + JSON.stringify(r.data);
      return false;
    }

    const rows = r.data.rows || [];
    const m = {};
    for (const x of rows) {
      m[String(x.fixture_id)] = x;
    }
    rawFixturesMap = m;
    document.getElementById("rawHint").textContent = `원본(raw) rows: ${rows.length}`;
    return true;
  }

  function diffObjects(a, b, path="", out=[]) {
    // a=raw, b=current
    const isObj = v => v && typeof v === "object" && !Array.isArray(v);
    const isArr = v => Array.isArray(v);

    if (isObj(a) && isObj(b)) {
      const keys = new Set([...Object.keys(a), ...Object.keys(b)]);
      for (const k of keys) {
        if (String(k).startsWith("_")) continue; // 내부 메타키 제외
        diffObjects(a[k], b[k], path ? (path + "." + k) : k, out);
      }
      return out;
    }

    if (isArr(a) || isArr(b)) {
      const sa = JSON.stringify(a);
      const sb = JSON.stringify(b);
      if (sa !== sb) out.push({ path, raw: a, now: b });
      return out;
    }

    // primitive / null / undefined
    if ((a ?? null) !== (b ?? null)) out.push({ path, raw: a, now: b });
    return out;
  }

  function updateComparisonViews() {
    // 현재(노출)
    document.getElementById("fxPreviewNow").textContent = JSON.stringify(selectedFixture || {}, null, 2);

    // patch는 textarea 기준
    let patchObj = null;
    try {
      patchObj = JSON.parse(document.getElementById("patch").value || "{}");
      if (!patchObj || typeof patchObj !== "object") patchObj = {};
    } catch (e) {
      patchObj = { _error: "patch JSON parse failed" };
    }
    document.getElementById("fxPreviewPatch").textContent = JSON.stringify(patchObj, null, 2);

    // raw + diff
    const raw = rawFixturesMap ? rawFixturesMap[String(selectedFixture?.fixture_id)] : null;
    document.getElementById("fxPreviewRaw").textContent = JSON.stringify(raw || {}, null, 2);

    if (raw && selectedFixture) {
      const diffs = diffObjects(raw, selectedFixture, "", []).slice(0, 200);

      const lines = diffs.map(d => {
        const a = JSON.stringify(d.raw);
        const b = JSON.stringify(d.now);
        return `${d.path}: ${a} -> ${b}`;
      });

      document.getElementById("fxPreviewDiff").textContent =
        lines.length ? lines.join("\n") : "(변경 없음)";
    } else {
      document.getElementById("fxPreviewDiff").textContent = "(비교 데이터 없음)";
    }

  }

    async function loadBundleViews() {
    if (!selectedFixture) {
      document.getElementById("bundlePreviewRaw").textContent = "{}";
      document.getElementById("bundlePreviewMerged").textContent = "{}";
      document.getElementById("bundlePreviewDiff").textContent = "[]";
      bundleRaw = null;
      bundleMerged = null;
      return;
    }

    const fx = selectedFixture.fixture_id;
    const lg = selectedFixture.league_id;
    const se = selectedFixture.season;

    if (fx == null || lg == null || se == null) {
      document.getElementById("bundlePreviewRaw").textContent = "{}";
      document.getElementById("bundlePreviewMerged").textContent = "{}";
      document.getElementById("bundlePreviewDiff").textContent = "[]";
      bundleRaw = null;
      bundleMerged = null;
      return;
    }

    const base = new URLSearchParams({
      fixture_id: String(fx),
      league_id: String(lg),
      season: String(se),
    });

    // raw (override 미적용)
    const qsRaw = new URLSearchParams(base);
    qsRaw.set("apply_override", "0");

    // merged (override 적용)
    const qsMerged = new URLSearchParams(base);
    qsMerged.set("apply_override", "1");

    // ✅ match_detail_bundle는 public endpoint이므로 publicApi 사용
    const r1 = await publicApi("/api/match_detail_bundle?" + qsRaw.toString());
    const r2 = await publicApi("/api/match_detail_bundle?" + qsMerged.toString());

    bundleRaw = (r1.status < 400 && r1.data && r1.data.ok) ? (r1.data.data || null) : null;
    bundleMerged = (r2.status < 400 && r2.data && r2.data.ok) ? (r2.data.data || null) : null;

    document.getElementById("bundlePreviewRaw").textContent =
      JSON.stringify(bundleRaw || { _error: "raw load failed", status: r1.status, data: r1.data }, null, 2);

    document.getElementById("bundlePreviewMerged").textContent =
      JSON.stringify(bundleMerged || { _error: "merged load failed", status: r2.status, data: r2.data }, null, 2);

    if (bundleRaw && bundleMerged) {
      const diffs = diffObjects(bundleRaw, bundleMerged, "", []).slice(0, 300);
      const lines = diffs.map(d => `${d.path}: ${JSON.stringify(d.raw)} -> ${JSON.stringify(d.now)}`);
      document.getElementById("bundlePreviewDiff").textContent =
        lines.length ? lines.join("\n") : "(변경 없음)";
    } else {
      document.getElementById("bundlePreviewDiff").textContent = "[]";
    }
  }



  async function selectFixture(fixtureId) {
    const f = currentFixtures.find(x => String(x.fixture_id) === String(fixtureId));
    if (!f) return;

    selectedFixture = f;
    renderFixtures();

    document.getElementById("fixtureId").value = String(f.fixture_id);
    fillQuickEditFromFixture(f);

    setStatusLine(`선택: fixture_id=${f.fixture_id}`);

    // override 조회(그리고 patch textarea 채움)
    await getOverride();

    // raw 로드 후 비교 뷰 갱신
    const ok = await ensureRawLoaded();
    if (!ok) {
      rawFixturesMap = rawFixturesMap || null;
    }
    updateComparisonViews();
  }

  async function loadFixtures() {
    const date = document.getElementById("fxDate").value;
    if (!date) {
      alert("Date를 선택하세요");
      return;
    }

    const qs = buildFixturesQuery();

    setStatusLine("fixtures 불러오는 중...");
    // ✅ 관리자용 merged(override 반영 + hidden 포함) 사용
    const r = await api(adminUrl(`/api/fixtures_merged?` + qs.toString()), { method: "GET" });

    if (r.status >= 400 || !r.data || !r.data.ok) {
      setStatusLine("");
      alert("fixtures 로드 실패: " + JSON.stringify(r.data));
      return;
    }

    currentFixtures = r.data.rows || [];

    // 선택 유지(저장/삭제 후 재선택을 위해)
    const keepId = selectedFixture ? String(selectedFixture.fixture_id) : "";
    selectedFixture = null;

    // raw 캐시 무효화(필터 변경될 수 있으니)
    rawFixturesMap = null;
    rawCacheKey = "";

    document.getElementById("fxPreviewNow").textContent = "{}";
    document.getElementById("fxPreviewRaw").textContent = "{}";
    document.getElementById("fxPreviewPatch").textContent = "{}";
    document.getElementById("fxPreviewDiff").textContent = "[]";
    document.getElementById("rawHint").textContent = "";

    // ✅ bundle 프리뷰도 초기화(선택이 해제되었는데 이전 데이터가 남는 문제 방지)
    document.getElementById("bundlePreviewRaw").textContent = "{}";
    document.getElementById("bundlePreviewMerged").textContent = "{}";
    document.getElementById("bundlePreviewDiff").textContent = "[]";
    bundleRaw = null;
    bundleMerged = null;


    setStatusLine("");
    renderFixtures();

    // ✅ 가능하면 이전 선택 재선택
    if (keepId) {
      const exists = currentFixtures.find(x => String(x.fixture_id) === keepId);
      if (exists) await selectFixture(keepId);
    }

    showTab("now");
  }


  async function getOverride() {
    const id = document.getElementById("fixtureId").value.trim();
    if (!id) return setOv("fixture_id가 필요합니다", false);

    const r = await api(adminUrl(`/api/overrides/${id}`), { method: "GET" });
    if (r.status < 400 && r.data) {
      const p = r.data.patch;
      if (p && typeof p === "object") {
        document.getElementById("patch").value = JSON.stringify(p, null, 2);
        setOv(`override 존재 · status=${r.status}`, true);
      } else {
        document.getElementById("patch").value = "";
        setOv(`override 없음 · status=${r.status}`, true);
      }
      updateComparisonViews();
      await loadBundleViews();
    } else {
      setOv(`status=${r.status} · ${JSON.stringify(r.data)}`, false);
    }
  }

  async function upsertOverride() {
    const id = document.getElementById("fixtureId").value.trim();
    if (!id) return setOv("fixture_id가 필요합니다", false);

    let patch = null;
    try {
      patch = JSON.parse(document.getElementById("patch").value || "{}");
    } catch (e) {
      return setOv("Patch JSON 파싱 실패", false);
    }

    const ok = confirm("저장(Upsert)할까요? (override가 즉시 적용됩니다)");
    if (!ok) return;

    const r = await api(adminUrl(`/api/overrides/${id}`), {
      method: "PUT",
      body: JSON.stringify(patch),
    });
    setOv(`status=${r.status} · ${JSON.stringify(r.data)}`, r.status < 400);

    if (r.status < 400) {
      // 저장 후 현재 목록 새로고침(노출 결과 갱신)
      await loadFixtures();
    }
  }

  async function deleteOverride() {
    const id = document.getElementById("fixtureId").value.trim();
    if (!id) return setOv("fixture_id가 필요합니다", false);

    const ok = confirm("삭제(원복)할까요? (override가 제거되고 원본으로 돌아갑니다)");
    if (!ok) return;

    const r = await api(adminUrl(`/api/overrides/${id}`), { method: "DELETE" });
    setOv(`status=${r.status} · ${JSON.stringify(r.data)}`, r.status < 400);

    if (r.status < 400) {
      document.getElementById("patch").value = "";
      updateComparisonViews();
      await loadFixtures();
    }
  }

  function applyQuickEditToPatch() {
    const id = document.getElementById("fixtureId").value.trim();
    if (!id) return setOv("fixture_id가 필요합니다", false);

    let basePatch = {};
    try {
      basePatch = JSON.parse(document.getElementById("patch").value || "{}");
      if (!basePatch || typeof basePatch !== "object" || Array.isArray(basePatch)) basePatch = {};
    } catch (e) {
      basePatch = {};
    }

    const p = {};

    const v = (document.getElementById("qeVenue").value || "").trim();
    const r = (document.getElementById("qeRound").value || "").trim();
    const sl = (document.getElementById("qeStatusLong").value || "").trim();
    const el = safeNum(document.getElementById("qeElapsed").value);

    if (v) p["venue_name"] = v;
    if (r) p["league_round"] = r;
    if (sl) p["status_long"] = sl;
    if (el !== null) p["elapsed"] = el;

    const hft = safeNum(document.getElementById("qeHomeFt").value);
    const aft = safeNum(document.getElementById("qeAwayFt").value);
    const hht = safeNum(document.getElementById("qeHomeHt").value);
    const aht = safeNum(document.getElementById("qeAwayHt").value);

    if (hft !== null || hht !== null) {
      p["home"] = p["home"] || {};
      if (hft !== null) p["home"]["ft"] = hft;
      if (hht !== null) p["home"]["ht"] = hht;
    }
    if (aft !== null || aht !== null) {
      p["away"] = p["away"] || {};
      if (aft !== null) p["away"]["ft"] = aft;
      if (aht !== null) p["away"]["ht"] = aht;
    }

    const merged = deepMerge(basePatch, p);
    document.getElementById("patch").value = JSON.stringify(merged, null, 2);
    setOv("Quick Edit 값을 Patch JSON에 반영했습니다(아직 저장 전).", true);
    updateComparisonViews();
  }

  async function hideFixture() {
    document.getElementById("patch").value = JSON.stringify({ hidden: true }, null, 2);
    setOv("hidden=true 패치를 세팅했습니다. 저장(Upsert) 누르면 적용됩니다.", true);
    updateComparisonViews();
  }

  async function unhideFixture() {
    document.getElementById("patch").value = JSON.stringify({ hidden: false }, null, 2);
    setOv("hidden=false 패치를 세팅했습니다. 저장(Upsert) 누르면 적용됩니다.", true);
    updateComparisonViews();
  }

  async function loadLogs() {
    const fx = document.getElementById("logFixture").value.trim();
    const ev = document.getElementById("logEvent").value;

    const qs = new URLSearchParams();
    qs.set("limit", "200");
    if (fx) qs.set("fixture_id", fx);
    if (ev) qs.set("event_type", ev);

    const r = await api(adminUrl(`/api/logs?` + qs.toString()), { method: "GET" });

    const body = document.getElementById("logsBody");
    body.innerHTML = "";

    if (r.status >= 400) {
      document.getElementById("logHint").textContent = "로그 로드 실패: " + JSON.stringify(r.data);
      return;
    }

    const rows = (r.data && r.data.rows) ? r.data.rows : [];
    for (const row of rows) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="mono">${row.ts || ""}</td>
        <td class="mono">${row.event_type || ""}</td>
        <td>${row.ok ? "✅" : "❌"}</td>
        <td class="mono">${JSON.stringify(row.detail || {})}</td>
      `;
      body.appendChild(tr);
    }

    document.getElementById("logHint").textContent = `rows: ${rows.length} (limit=200)`;
  }

  document.getElementById("fxDate").value = isoDateLocal();
  document.getElementById("fxTz").value = "Asia/Seoul";

  loadFixtures();
  loadLogs();
</script>
</body>
</html>
