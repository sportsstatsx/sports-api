<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Board Posts</title>
  <style>
    :root {
      --bg: #0b0d10;
      --panel: #11141a;
      --panel2: #0f1218;
      --text: #e6e9ef;
      --muted: rgba(230, 233, 239, 0.7);
      --line: rgba(230, 233, 239, 0.12);
      --line2: rgba(230, 233, 239, 0.18);
      --accent: #46d39a;
      --danger: #ff5a6a;
      --warn: #ffcc66;
      --shadow: 0 10px 40px rgba(0,0,0,0.35);
      --radius: 14px;
      --radius2: 18px;
      --pad: 14px;
      --pad2: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --sans: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    }

    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f5f7fb;
        --panel: #ffffff;
        --panel2: #ffffff;
        --text: #0b0d10;
        --muted: rgba(11, 13, 16, 0.6);
        --line: rgba(11, 13, 16, 0.12);
        --line2: rgba(11, 13, 16, 0.16);
        --shadow: 0 10px 40px rgba(10,20,30,0.10);
      }
    }

    /* ✅ admin.html의 ssx_theme 메시지로 강제 테마 적용 */
    :root[data-theme="light"] {
      --bg: #f5f7fb;
      --panel: #ffffff;
      --panel2: #ffffff;
      --text: #0b0d10;
      --muted: rgba(11, 13, 16, 0.6);
      --line: rgba(11, 13, 16, 0.12);
      --line2: rgba(11, 13, 16, 0.16);
      --shadow: 0 10px 40px rgba(10,20,30,0.10);
    }
    :root[data-theme="dark"] {
      --bg: #0b0d10;
      --panel: #11141a;
      --panel2: #0f1218;
      --text: #e6e9ef;
      --muted: rgba(230, 233, 239, 0.7);
      --line: rgba(230, 233, 239, 0.12);
      --line2: rgba(230, 233, 239, 0.18);
      --shadow: 0 10px 40px rgba(0,0,0,0.35);
    }

    /* ✅ 네이티브 폼 컨트롤(select/option 등) 테마를 브라우저에 힌트 */
:root[data-theme="dark"] { color-scheme: dark; }
:root[data-theme="light"] { color-scheme: light; }

/* ✅ select/option 기본 배경 하얗게 뜨는 것 최대한 방지 */
select {
  background: rgba(0,0,0,0.15);
  color: var(--text);
}
:root[data-theme="light"] select {
  background: rgba(255,255,255,0.85);
  color: var(--text);
}

/* 일부 브라우저에서 option 배경이 강제로 하얗게 뜨는 경우 완화 */
select option {
  background: var(--panel);
  color: var(--text);
}



    body {
      margin: 0;
      padding: 18px;
      background: var(--bg);
      color: var(--text);
      font-family: var(--sans);
    }

    h1 {
      margin: 0 0 12px 0;
      font-size: 22px;
      letter-spacing: 0.2px;
    }

    .topbar {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      margin-bottom: 14px;
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
    }

    /* ✅ 이제 화면 전환형이라 wrap grid는 사용 안함 */
    .wrap { display:none; }

    /* 목록 아이템 안의 액션 버튼 */
    .item .metaRight {
      display:flex;
      align-items:center;
      gap: 8px;
    }
    .item .actions {
      display:flex;
      gap: 6px;
      align-items:center;
    }


    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border: 1px solid var(--line);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    /* ✅ Editor 폭은 .editorNarrow(420px)에서만 제어 (카드 max-width 제한 제거) */


    /* (선택) Content 작성칸을 monospace 대신 일반 폰트로 */
    #pContent {
      font-family: var(--sans);
      line-height: 1.6;

      /* ✅ 긴 단어/URL이 모바일에서 레이아웃 튀는 것 방지 */
      word-break: break-word;
      overflow-wrap: anywhere;
    }




    .card h2 {
      margin: 0;
      padding: 12px 14px;
      font-size: 14px;
      color: var(--text);
      border-bottom: 1px solid var(--line);
      background: rgba(255,255,255,0.02);
    }

    .card .body {
      padding: 14px;
    }

    /* ✅ Editor 폭을 모바일 본문 느낌으로 제한 (대략 320~420px) */
    .editorNarrow {
      width: 100%;
      max-width: 420px;   /* 폰 느낌 상한 */
      margin: 0 auto;     /* 가운데 정렬 */
    }

    /* Editor 안 입력들은 폭 100% 유지 */
    .editorNarrow input,
    .editorNarrow select,
    .editorNarrow textarea {
      width: 100%;
      box-sizing: border-box;
    }

    /* Content 텍스트는 '폰에서 보이는 줄바꿈' 느낌: 가로 리사이즈 금지 */
    .editorNarrow textarea#pContent {
      resize: vertical;   /* 이미 vertical이지만 확실히 */
    }


    .row { display:flex; gap:10px; flex-wrap: wrap; align-items: center; }
    .col { display:flex; flex-direction: column; gap: 6px; }
    label { font-size: 12px; color: var(--muted); }
    input, select, textarea {
      width: 100%;
      padding: 10px 10px;
      font-size: 13px;
      border-radius: 12px;
      border: 1px solid var(--line2);
      background: rgba(0,0,0,0.15);
      color: var(--text);
      outline: none;
    }
    textarea { min-height: 170px; resize: vertical; font-family: var(--mono); line-height: 1.35; }

    /* ✅ FIX: 공통 폼룰이 select 스타일을 덮어쓰는 문제 방지 (라이트/다크 안정화) */
    :root[data-theme="dark"] select {
      background: rgba(0,0,0,0.15) !important;
      color: var(--text) !important;
    }
    :root[data-theme="light"] select {
      background: rgba(255,255,255,0.85) !important;
      color: var(--text) !important;
    }
    :root[data-theme="dark"] select option,
    :root[data-theme="light"] select option {
      background: var(--panel) !important;
      color: var(--text) !important;
    }


    .btn {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--line2);
      background: rgba(255,255,255,0.03);
      color: var(--text);
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
    }
    .btn:hover { border-color: rgba(255,255,255,0.28); }
    .btn.primary { border-color: rgba(70,211,154,0.55); }
    .btn.danger { border-color: rgba(255,90,106,0.55); color: var(--danger); }
    .btn.small { padding: 6px 10px; font-size: 12px; border-radius: 10px; }

    .list {
      display:flex;
      flex-direction: column;
      gap: 10px;
      max-height: 520px;
      overflow: auto;
      padding-right: 6px;
    }

    .item {
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.02);
      cursor: pointer;
    }

    .item:hover { border-color: rgba(255,255,255,0.25); }
    .item.active { border-color: rgba(70,211,154,0.7); box-shadow: 0 0 0 2px rgba(70,211,154,0.15) inset; }

    .item .meta {
      display:flex;
      justify-content: space-between;
      gap: 10px;
      align-items: center;
      color: var(--muted);
      font-size: 12px;
    }

    .item .title {
      margin-top: 6px;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.2px;
      word-break: break-word;
    }

    .badges { display:flex; gap: 6px; flex-wrap: wrap; align-items: center; }
    .badge {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--line2);
      background: rgba(255,255,255,0.03);
      color: var(--muted);
    }
    .badge.pub { border-color: rgba(70,211,154,0.55); color: var(--accent); }
    .badge.pin { border-color: rgba(255,204,102,0.55); color: var(--warn); }
    .badge.cat { color: var(--text); opacity: 0.9; }

    .split {
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .mono {
      font-family: var(--mono);
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,0.18);
      max-height: 220px;
      overflow: auto;
    }

    .subtle {
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
    }

    .langs {
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .chip {
      display:inline-flex;
      gap: 6px;
      align-items: center;
      border: 1px solid var(--line2);
      border-radius: 999px;
      padding: 6px 10px;
      background: rgba(255,255,255,0.03);
      font-size: 12px;
      color: var(--text);
      cursor: pointer;
      user-select: none;
    }
    .chip input { width:auto; margin:0; }
    /* ─────────────────────────────────────
       Match Preview (Title 아래 매치카드)
       ───────────────────────────────────── */
    .matchPreview {
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
      background: rgba(255,255,255,0.02);
    }
    .matchPreview .mpTop {
      display:flex;
      align-items:center;
      gap: 8px;
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 8px;
    }
    .matchPreview .mpRow {
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .matchPreview .team {
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
    }
    .matchPreview .team.right { flex-direction: row-reverse; }
    .matchPreview .logo {
      width: 22px;
      height: 22px;
      border-radius: 6px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,0.15);
      object-fit: cover;
      flex: 0 0 auto;
    }
    .matchPreview .name {
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 240px;
    }
    .matchPreview .vs {
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 0.8px;
      padding: 0 6px;
      border-left: 1px solid var(--line);
      border-right: 1px solid var(--line);
    }

    /* ─────────────────────────────────────
       Fixture Picker Modal (Board)
       ───────────────────────────────────── */
    .fxRow {
      display:flex;
      gap: 8px;
      align-items:center;
    }
    .fxRow input {
      flex: 1;
      min-width: 0;
    }
    .fxRow .btn {
      width: auto;
      flex: 0 0 auto;
      white-space: nowrap;
    }

    .modal {
      position: fixed;
      inset: 0;
      /* ✅ 뒤 배경 더 확실히 눌러서 “반투명/비침” 느낌 제거 */
      background: rgba(0,0,0,0.75);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 9999;
    }

    /* 라이트 테마에서는 오버레이가 너무 어둡지 않게 */
    :root[data-theme="light"] .modal {
      background: rgba(0,0,0,0.35);
    }

    .modalCard {
      /* ✅ 가로 폭 더 줄임 */
      width: min(860px, 92vw);
      max-height: min(86vh, 860px);

      /* ✅ background가 어떤 경우에도 gradient/투명으로 덮이지 않도록 강제 */
      background-color: var(--panel);
      background-image: none;
      background: var(--panel);

      border: 1px solid var(--line2);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow: hidden;
      display:flex;
      flex-direction: column;
    }


    .modalTop {
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);

      /* ✅ 헤더도 solid */
      background: var(--panel2);
    }

    .modalTitle {
      font-size: 14px;
      font-weight: 800;
      letter-spacing: 0.2px;
    }

    /* ✅ 모달 안 폼 컨트롤이 rgba라서 “반투명처럼” 보이는 문제 해결 */
    .modalCard input,
    .modalCard select,
    .modalCard textarea {
      background: var(--panel2);
    }



    /* ✅ Fixtures Browser 필터: (From/To) + TZ + LeaguePick + Search + 버튼 우측 고정 */
    .fxControls {
      display: grid;
      grid-template-columns: 180px 180px 220px 1fr 160px;
      grid-template-areas:
        "from to tz league btn"
        "search search search search btn";
      gap: 10px;
      align-items: end;
    }

    .fxControls .col { gap: 4px; min-width: 0; }

    .fxColDate { grid-area: from; }
    .fxColDateTo { grid-area: to; }
    .fxColTz { grid-area: tz; }
    .fxColLeaguePick { grid-area: league; }
    .fxColSearch { grid-area: search; }
    .fxColBtn { grid-area: btn; align-self: stretch; }

    /* ✅ 버튼 컬럼의 라벨은 공간만 유지하고 안 보이게 */
    .fxColBtn label { visibility: hidden; }

    /* ✅ 모달 안에서만 폼 높이/패딩 통일 */
    .fxControls input,
    .fxControls select {
      height: 40px;
      padding: 0 12px;
      box-sizing: border-box;
    }

    /* ✅ League pick row */
    .fxLeaguePickWrap {
      display: flex;
      gap: 6px;
      align-items: center;
      min-width: 0;
    }
    .fxLeaguePickWrap select {
      flex: 1;
      min-width: 0;
    }

    .fxLeaguePills {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    .fxPillGroup {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--line2);
      background: rgba(255,255,255,0.03);
      font-size: 12px;
      color: var(--text);
      user-select: none;
    }
    .fxPillX {
      font-weight: 900;
      cursor: pointer;
      opacity: 0.75;
    }
    .fxPillX:hover { opacity: 1; }

    /* ✅ 불러오기 버튼도 인풋 높이와 동일 + 컬럼 꽉 채우기 */
    .fxControls .btn.fxBtn {
      height: 40px;
      width: 100%;
      padding: 0 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
    }

    /* ✅ 좁은 화면에서는 2열 + 버튼 full */
    @media (max-width: 860px) {
      .fxControls {
        grid-template-columns: 1fr 1fr;
        grid-template-areas:
          "from to"
          "tz tz"
          "league league"
          "search search"
          "btn btn";
      }
      .fxColBtn label { display:none; }
    }




    .fxList {
      margin-top: 12px;
      display:flex;
      flex-direction: column;
      gap: 8px;
      max-height: 520px;
      overflow: auto;
      padding-right: 6px;
    }
    .fxItem {
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 10px 12px;

      /* ✅ 리스트 아이템을 solid 패널로 */
      background: var(--panel2);

      cursor: pointer;
      display:flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
    }

    .fxItem:hover {
      border-color: rgba(255,255,255,0.28);
      /* hover도 “하얗게 확 변하는” 느낌 말고 살짝만 */
      background: rgba(255,255,255,0.04);
    }

    :root[data-theme="light"] .fxItem:hover {
      background: rgba(0,0,0,0.03);
    }

    .fxLeft {
      min-width: 0;
      flex: 1;
    }
    .fxMeta {
      font-size: 12px;
      color: var(--muted);
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .fxTitle {
      margin-top: 6px;
      font-size: 14px;
      font-weight: 800;
      letter-spacing: 0.2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .fxTeams {
      margin-top: 6px;
      display:flex;
      align-items:center;
      gap: 8px;
      min-width: 0;
    }
    .fxLogo {
      width: 18px;
      height: 18px;
      border-radius: 6px;
      border: 1px solid var(--line);
      background: var(--panel2);
      object-fit: cover;
      flex: 0 0 auto;
    }
    .fxTeamName {
      font-size: 14px;
      font-weight: 800;
      letter-spacing: 0.2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 0;
    }
    .fxVs {
      font-size: 12px;
      font-weight: 900;
      opacity: 0.65;
      flex: 0 0 auto;
      padding: 0 2px;
    }

    .fxRight {
      display:flex;
      align-items:center;
      gap: 10px;
      flex: 0 0 auto;
      color: var(--muted);
      font-size: 12px;
      text-align: right;
      white-space: nowrap;
    }
    .fxScore {
      font-size: 14px;
      font-weight: 900;
      color: var(--text);
      letter-spacing: 0.5px;
    }
    .fxPill {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--line2);
      background: rgba(255,255,255,0.03);
      color: var(--muted);
    }

  </style>

</head>
<body>
  <div class="topbar">
    <div>
      <h1>Board Posts</h1>
      <div class="hint">경로: <span id="pathHint"></span> · API 헤더: <code>X-Admin-Token</code> 필요</div>
    </div>
    <div class="row">
      <button class="btn" onclick="loadPosts()">불러오기</button>
      <button class="btn" onclick="newPost()">+ 새 글</button>
    </div>
  </div>

  <!-- ✅ 게시판 형태: List View / Editor View -->
<div id="listView">
  <div class="card">
    <h2>Posts</h2>
    <div class="body">
      <div class="row">
        <div class="col" style="min-width: 110px; flex:1">
          <label>Status</label>
          <select id="qStatus">
            <option value="">(all)</option>
            <option value="draft">draft</option>
            <option value="published">published</option>
            <option value="hidden">hidden</option>
          </select>
        </div>
        <div class="col" style="min-width: 120px; flex:1">
          <label>Category</label>
          <select id="qCategory">
            <option value="">(all)</option>
            <option value="notice">notice</option>
            <option value="ops">ops</option>
            <option value="analysis">analysis</option>
          </select>
        </div>
        <div class="col" style="min-width: 120px; flex:1">
          <label>Sport</label>
          <select id="qSport">
            <option value="">(all)</option>
            <option value="football">football</option>
            <option value="hockey">hockey</option>
          </select>
        </div>
        <div class="col" style="min-width: 170px; flex:2">
          <label>Search (title/summary)</label>
          <input id="qText" placeholder="예: Arsenal / 공지 / injury" />
        </div>
      </div>

      <div class="row" style="margin-top: 10px;">
        <div class="col" style="flex: 1;">
          <label>Fixture Key (optional)</label>
          <input id="qFixtureKey" placeholder="예: football:123456 / hockey:2025-01-01-XYZ" />
        </div>
        <div class="col" style="min-width: 110px;">
          <label>&nbsp;</label>
          <button class="btn" onclick="loadPosts()">불러오기</button>
        </div>
      </div>

      <div class="subtle" id="listHint"></div>
      <div class="list" id="list"></div>
    </div>
  </div>
</div>

<div id="editorView" style="display:none;">
  <div class="card">
    <h2 style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
      <span>Editor</span>
      <button class="btn small" onclick="backToList()">← 목록</button>
    </h2>

    <div class="body">
      <div class="editorNarrow">
        <!-- ✅ 여기부터는 너 기존 Editor 내용 그대로 유지 -->
        <div class="row">
          <div class="col" style="min-width: 100px;">
            <label>ID</label>
            <input id="pId" disabled placeholder="(new)" />
          </div>
          <div class="col" style="min-width: 140px; flex:1;">
            <label>Category</label>
            <select id="pCategory">
              <option value="analysis">analysis</option>
              <option value="notice">notice</option>
              <option value="ops">ops</option>
            </select>
          </div>
          <div class="col" style="min-width: 140px; flex:1;">
            <label>Status</label>
            <select id="pStatus">
              <option value="draft">draft</option>
              <option value="published">published</option>
              <option value="hidden">hidden</option>
            </select>
          </div>
          <div class="col" style="min-width: 160px; flex:1;">
            <label>Pin level</label>
            <select id="pPin">
              <option value="0">0 (일반)</option>
              <option value="1">1 (고정)</option>
              <option value="2">2 (공지/운영 최상단)</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top: 10px;">
          <div class="col" style="min-width: 200px; flex:1;">
            <label>Sport (optional)</label>
            <select id="pSport">
              <option value="">(none)</option>
              <option value="football">football</option>
              <option value="hockey">hockey</option>
            </select>
          </div>
          <div class="col" style="min-width: 240px; flex:1;">
            <label>Fixture Key (optional)</label>
            <div class="fxRow">
              <input id="pFixtureKey" placeholder="예: 123456" />
              <button class="btn small" type="button" onclick="openFixturePicker()">선택</button>
            </div>
          </div>

        </div>

        <div class="row" style="margin-top: 10px;">
          <div class="col" style="min-width: 220px; flex:1;">
            <label>Publish at (optional)</label>
            <input id="pPublishAt" type="datetime-local" />
          </div>
          <div class="col" style="min-width: 220px; flex:1;">
            <label>Pin until (optional)</label>
            <input id="pPinUntil" type="datetime-local" />
          </div>
        </div>

        <div class="row" style="margin-top: 10px;">
          <div class="col" style="flex: 1;">
            <label>Title</label>
            <input id="pTitle" placeholder="제목" />
          </div>
        </div>

        <div class="row" style="margin-top: 10px;">
          <div class="col" style="flex: 1;">
            <div id="matchPreview" class="matchPreview" style="display:none;"></div>
          </div>
        </div>

        <div class="row" style="margin-top: 10px;">
          <div class="col" style="flex: 1;">
            <label>Summary (list에 뽑힐 짧은 요약)</label>
            <input id="pSummary" placeholder="요약(선택)" />
          </div>
        </div>

        <div class="row" style="margin-top: 10px;">
          <div class="col" style="flex: 1;">
            <label>Content (Markdown)</label>
            <textarea id="pContent" placeholder="# 제목&#10;&#10;내용..."></textarea>
          </div>
        </div>

        <div class="row" style="margin-top: 10px;">
          <div class="col" style="flex: 1;">
            <label>Target Langs (비우면 전세계)</label>
            <div class="langs" id="langBox"></div>
            <div class="subtle">예: 영어 글이면 <b>en</b>만 체크. 비우면 모든 언어권에 노출.</div>
          </div>
        </div>

        <div class="row" style="margin-top: 10px;">
          <div class="col" style="flex: 1;">
            <label>(옵션) Snapshot JSON / Filters JSON</label>
            <button class="btn small" onclick="toggleJsonPanel()">JSON 패널 열기/닫기</button>
          </div>
        </div>

        <div id="jsonPanel" style="display:none; margin-top: 10px;">
          <div class="split">
            <div class="col">
              <label>Filters JSON</label>
              <textarea id="pFiltersJson" style="min-height:140px;">{}</textarea>
            </div>
            <div class="col">
              <label>Snapshot JSON</label>
              <textarea id="pSnapshotJson" style="min-height:140px;">{}</textarea>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top: 12px;">
          <button class="btn primary" onclick="savePost()">저장(Upsert)</button>
          <button class="btn danger" onclick="deletePost()">삭제</button>
          <button class="btn" onclick="reloadSelected()">새로고침</button>
          <div class="hint" id="saveHint" style="margin-left:auto;"></div>
        </div>

        <div class="subtle">Debug</div>
        <div class="mono" id="debugBox">{}</div>
      </div>
    </div>
  </div>
</div>

<!-- ✅ Fixture Picker Modal -->
<div id="fixtureModal" class="modal" aria-hidden="true">
  <div class="modalCard" role="dialog" aria-modal="true">
    <div class="modalTop">
      <div class="modalTitle">Fixtures Browser</div>
      <div class="row" style="margin:0;">
        <button class="btn small" type="button" onclick="closeFixturePicker()">닫기</button>
      </div>
    </div>

    <div class="modalBody">
      <div class="fxControls">
        <div class="col fxColDate">
          <label>Date (From)</label>
          <input id="fxDate" type="date" />
        </div>

        <div class="col fxColDateTo">
          <label>Date (To)</label>
          <input id="fxDateTo" type="date" />
        </div>

        <div class="col fxColTz">
          <label>Timezone</label>
          <select id="fxTz">
            <option value="Asia/Seoul">Asia/Seoul</option>
            <option value="UTC">UTC</option>
            <option value="Europe/London">Europe/London</option>
            <option value="Europe/Paris">Europe/Paris</option>
            <option value="America/New_York">America/New_York</option>
          </select>
        </div>

        <div class="col fxColLeaguePick">
          <label>League Filter (from loaded list)</label>

          <div class="fxLeaguePickWrap">
            <select id="fxLeaguePick">
              <option value="">(전체 리그)</option>
            </select>

            <button class="btn small" type="button" onclick="fxAddLeagueFromPick()">+</button>
            <button class="btn small" type="button" onclick="fxRemoveLeagueFromPick()">-</button>
            <button class="btn small" type="button" onclick="fxClearLeagueFilter()">ALL</button>
          </div>

          <div id="fxLeaguePills" class="fxLeaguePills"></div>

          <!-- ✅ 선택된 league_ids는 여기(hidden)에 CSV로 저장 -->
          <input id="fxLeagueIds" type="hidden" value="" />
        </div>

        <div class="col fxColSearch">
          <label>Search (team/league)</label>
          <input id="fxSearch" placeholder="예: Arsenal / LaLiga" />
        </div>

        <div class="col fxColBtn">
          <label>&nbsp;</label>
          <button class="btn fxBtn" type="button" onclick="loadFixtureBrowser()">불러오기</button>
        </div>
      </div>



      <div class="subtle" id="fxStatus" style="margin-top:10px;"></div>
      <div class="fxList" id="fxList"></div>
    </div>
  </div>
</div>

<script>

  // ─────────────────────────────────────
  // Helpers
  // ─────────────────────────────────────
  const LANG_OPTIONS = ["en", "es", "ko", "ja", "zh"]; // 필요하면 확장
  let cachedRows = [];
  let selectedId = null;

  function adminUrl(path) {
  // 예: /admin19900731/pages/board.html  ->  /admin19900731
  const base = location.pathname.replace(/\/pages\/[^\/]+$/, "");
  return base + path;
}


  function $(id) { return document.getElementById(id); }

  function setDebug(obj) {
    $("debugBox").textContent = JSON.stringify(obj, null, 2);
  }

  function setSaveHint(msg) { $("saveHint").textContent = msg || ""; }
  function setStatusLine(msg) { $("listHint").textContent = msg || ""; }

  function escapeHtml(s) {
    return String(s || "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  // ✅ 로고 URL이 없거나 깨지면 깔끔하게 대체(투명 1px)
  const _EMPTY_LOGO =
    "data:image/gif;base64,R0lGODlhAQABAAAAACwAAAAAAQABAAA=";

  function safeLogo(u) {
    const s = (u == null) ? "" : String(u).trim();
    return s ? s : _EMPTY_LOGO;
  }

function formatKickoffLine(fixture) {
  const leagueName = fixture?.league?.name ? String(fixture.league.name).trim() : "";
  const kickoff = fixture?.kickoff_utc ? String(fixture.kickoff_utc).slice(0, 16).replace("T", " ") : "";
  if (leagueName && kickoff) return `${leagueName} · ${kickoff}`;
  return leagueName || kickoff || "";
}

function formatTeamsLine(fixture) {
  const home = fixture?.home?.name ? String(fixture.home.name).trim() : "";
  const away = fixture?.away?.name ? String(fixture.away.name).trim() : "";
  if (home && away) return `${home} vs ${away}`;
  return home || away || "";
}

// ✅ 2줄 타이틀 고정 포맷 (리그/시간 + 팀 vs 팀)
function buildTwoLineTitleFromFixture(fixture) {
  const line1 = formatKickoffLine(fixture);
  const line2 = formatTeamsLine(fixture);
  return [line1, line2].filter(Boolean).join("\n");
}


  
  function isoToDatetimeLocal(iso) {
    if (!iso) return "";
    const d = new Date(iso);
    const pad = (n) => String(n).padStart(2, "0");
    const y = d.getFullYear();
    const m = pad(d.getMonth() + 1);
    const da = pad(d.getDate());
    const hh = pad(d.getHours());
    const mm = pad(d.getMinutes());
    return `${y}-${m}-${da}T${hh}:${mm}`;
  }

  function toIsoOrNull(datetimeLocal) {
    const v = (datetimeLocal || "").trim();
    if (!v) return null;
    const d = new Date(v);
    if (isNaN(d.getTime())) return null;
    return d.toISOString();
  }

  async function api(url, opts) {
  const token =
    localStorage.getItem("SSX_ADMIN_TOKEN") ||
    localStorage.getItem("adminToken") ||
    "";

  const headers = Object.assign({
    "Content-Type": "application/json",
    "X-Admin-Token": token,
  }, (opts && opts.headers) || {});

  try {
    const res = await fetch(url, Object.assign({}, opts || {}, { headers }));
    let data = null;
    try { data = await res.json(); } catch(e) {}
    return { status: res.status, data };
  } catch (e) {
    return { status: 0, data: { ok: false, error: String(e) } };
  }
}


function showListView() {
  $("listView").style.display = "block";
  $("editorView").style.display = "none";
}

function showEditorView() {
  $("listView").style.display = "none";
  $("editorView").style.display = "block";
}

function backToList() {
  showListView();
  setSaveHint("");
  loadPosts();
}




  // ─────────────────────────────────────
  // Lang chips
  // ─────────────────────────────────────
  function renderLangBox() {
    const box = $("langBox");
    box.innerHTML = "";
    for (const code of LANG_OPTIONS) {
      const id = "lang_" + code;
      const chip = document.createElement("label");
      chip.className = "chip";
      chip.innerHTML = `<input type="checkbox" id="${id}" value="${code}"> <span>${code}</span>`;
      box.appendChild(chip);
    }
  }

  function getSelectedLangs() {
    const out = [];
    for (const code of LANG_OPTIONS) {
      const el = $("lang_" + code);
      if (el && el.checked) out.push(code);
    }
    return out;
  }

  function setSelectedLangs(arr) {
    const set = new Set((arr || []).map(x => String(x).toLowerCase().trim()).filter(Boolean));
    for (const code of LANG_OPTIONS) {
      const el = $("lang_" + code);
      if (el) el.checked = set.has(code);
    }
  }

  function toggleJsonPanel() {
    const p = $("jsonPanel");
    p.style.display = (p.style.display === "none" ? "block" : "none");
  }

  // ─────────────────────────────────────
  // List render
  // ─────────────────────────────────────
  function renderList() {
  const list = $("list");
  list.innerHTML = "";

  const rows = cachedRows || [];
  setStatusLine("rows: " + rows.length);

  for (const r of rows) {
    const div = document.createElement("div");
    div.className = "item" + (String(r.id) === String(selectedId) ? " active" : "");

    const badges = [];
    if (r.status === "published") badges.push(`<span class="badge pub">PUB</span>`);
    badges.push(`<span class="badge cat">${escapeHtml(r.category || "")}</span>`);
    if ((r.pin_level || 0) > 0) badges.push(`<span class="badge pin">PIN ${escapeHtml(String(r.pin_level))}</span>`);

    const tlangs = (r.target_langs || []);
    if (tlangs.length > 0) badges.push(`<span class="badge">langs: ${escapeHtml(tlangs.join(","))}</span>`);

    div.innerHTML = `
      <div class="meta">
        <div>#${escapeHtml(r.id)} · ${escapeHtml((r.publish_at || r.created_at || "").slice(0, 16))}</div>

        <div class="metaRight">
          <div class="badges">${badges.join("")}</div>
          <div class="actions">
            <button class="btn small" data-act="edit">수정</button>
            <button class="btn small danger" data-act="del">삭제</button>
          </div>
        </div>
      </div>

      <div class="title">${escapeHtml(r.title || "")}</div>
    `;

    // 아이템 클릭: 그냥 선택만 (원하면 edit로 바로 보내도 됨)
    div.onclick = () => {
      selectedId = String(r.id);
      renderList();
    };

    // 액션 버튼 이벤트 (버블링 막기)
    div.querySelector('[data-act="edit"]').onclick = (ev) => {
      ev.stopPropagation();
      selectPost(r.id, { openEditor: true });
    };
    div.querySelector('[data-act="del"]').onclick = (ev) => {
      ev.stopPropagation();
      deletePostById(r.id);
    };

    list.appendChild(div);
  }
}


  // ─────────────────────────────────────
  // Load / Select
  // ─────────────────────────────────────
  async function loadPosts() {
    const qs = new URLSearchParams();
    const st = ($("qStatus").value || "").trim();
    const cat = ($("qCategory").value || "").trim();
    const sp = ($("qSport").value || "").trim();
    const q = ($("qText").value || "").trim();
    const fx = ($("qFixtureKey").value || "").trim();

    if (st) qs.set("status", st);
    if (cat) qs.set("category", cat);
    if (sp) qs.set("sport", sp);
    if (q) qs.set("q", q);
    if (fx) qs.set("fixture_key", fx);

    qs.set("limit", "200");
    qs.set("offset", "0");

    setStatusLine("불러오는 중...");
    const r = await api(adminUrl("/api/board/posts?" + qs.toString()), { method: "GET" });
    setDebug(r);

    if (r.status >= 400 || !r.data || !r.data.ok) {
      setStatusLine("");
      alert("로드 실패: " + JSON.stringify(r.data));
      return;
    }

    cachedRows = r.data.rows || [];
    setStatusLine("");
    renderList();

    if (selectedId) {
      const exists = cachedRows.find(x => String(x.id) === String(selectedId));
      if (!exists) selectedId = null;
      renderList();
    }
  }

  async function selectPost(id, opts) {
  if (!id) return;
  selectedId = String(id);
  renderList();

  setStatusLine("불러오는 중: #" + id);
  const r = await api(adminUrl("/api/board/posts/" + id), { method: "GET" });
  setDebug(r);

  if (r.status >= 400 || !r.data || !r.data.ok) {
    setStatusLine("");
    alert("불러오기 실패: " + JSON.stringify(r.data));
    return;
  }

  fillEditor(r.data.row || {});
  setStatusLine("");

  const openEditor = !opts ? true : (opts.openEditor !== false);
  if (openEditor) showEditorView();
}


  function clearEditor() {
    selectedId = null;
    $("pId").value = "";
    $("pCategory").value = "analysis";
    $("pStatus").value = "draft";
    $("pPin").value = "0";
    $("pSport").value = "";
    $("pFixtureKey").value = "";
    $("pPublishAt").value = "";
    $("pPinUntil").value = "";
    $("pTitle").value = "";
    $("pSummary").value = "";
    $("pContent").value = "";
    setSelectedLangs([]);
    $("pFiltersJson").value = "{}";
    $("pSnapshotJson").value = "{}";

    // ✅ 매치 프리뷰 숨김
    hideMatchPreview();

    renderList();
  }


  function newPost() {
  clearEditor();
  setSaveHint("새 글 작성 중");
  showEditorView();
}


  function fillEditor(row) {
    selectedId = String(row.id ?? "");
    $("pId").value = selectedId;

    $("pCategory").value = (row.category || "analysis");
    $("pStatus").value = (row.status || "draft");
    $("pPin").value = String(row.pin_level ?? 0);

    $("pSport").value = (row.sport || "");
    $("pFixtureKey").value = (row.fixture_key || "");

    $("pPublishAt").value = isoToDatetimeLocal(row.publish_at || "");
    $("pPinUntil").value = isoToDatetimeLocal(row.pin_until || "");

    $("pTitle").value = (row.title || "");
    $("pSummary").value = (row.summary || "");
    $("pContent").value = (row.content_md || "");

    setSelectedLangs(row.target_langs || []);

    try {
      const fj = row.filters_json ?? {};
      $("pFiltersJson").value = (typeof fj === "string") ? fj : JSON.stringify(fj, null, 2);
    } catch (e) {
      $("pFiltersJson").value = "{}";
    }
    try {
      const sj = row.snapshot_json ?? {};
      $("pSnapshotJson").value = (typeof sj === "string") ? sj : JSON.stringify(sj, null, 2);
    } catch (e) {
      $("pSnapshotJson").value = "{}";
    }

    // ✅ 스냅샷 기반 프리뷰 렌더 (없으면 숨김)
    renderMatchPreviewFromSnapshot();

    setSaveHint("편집 중: #" + selectedId);
    renderList();
  }


  async function reloadSelected() {
    if (!selectedId) return alert("선택된 글이 없습니다.");
    await selectPost(selectedId);
  }

async function deletePostById(id) {
  const targetId = String(id || "").trim();
  if (!targetId) return;

  const ok = confirm("정말 삭제할까요? (#" + targetId + ")");
  if (!ok) return;

  setStatusLine("삭제 중: #" + targetId);
  const r = await api(adminUrl("/api/board/posts/" + targetId), { method: "DELETE" });
  setDebug(r);

  if (r.status >= 400 || !r.data || !r.data.ok) {
    setStatusLine("");
    alert("삭제 실패: " + JSON.stringify(r.data));
    return;
  }

  setStatusLine("");
  if (selectedId === targetId) selectedId = null;
  await loadPosts();
}


  // ─────────────────────────────────────
  // Save / Delete
  // ─────────────────────────────────────
  function buildPayload() {
    const title = ($("pTitle").value || "").trim();
    const content = ($("pContent").value || "").trim();

    const filtersStr = ($("pFiltersJson").value || "").trim() || "{}";
    const snapshotStr = ($("pSnapshotJson").value || "").trim() || "{}";

    let filtersObj = {};
    let snapshotObj = {};
    try { filtersObj = JSON.parse(filtersStr); } catch (e) { throw new Error("filters_json JSON 파싱 실패"); }
    try { snapshotObj = JSON.parse(snapshotStr); } catch (e) { throw new Error("snapshot_json JSON 파싱 실패"); }

    return {
      category: ($("pCategory").value || "analysis"),
      status: ($("pStatus").value || "draft"),
      pin_level: Number($("pPin").value || 0),

      sport: ($("pSport").value || "").trim() || null,
      fixture_key: ($("pFixtureKey").value || "").trim() || null,

      title,
      summary: ($("pSummary").value || "").trim(),
      content_md: content,

      publish_at: toIsoOrNull($("pPublishAt").value),
      pin_until: toIsoOrNull($("pPinUntil").value),

      // ✅ 언어권만
      target_langs: getSelectedLangs(),

      filters_json: filtersObj,
      snapshot_json: snapshotObj,
    };
  }

  // ─────────────────────────────────────
  // Theme sync (from admin.html iframe postMessage)
  // ─────────────────────────────────────
  function applyTheme(theme) {
    if (theme !== "light" && theme !== "dark") return;
    document.documentElement.dataset.theme = theme;
  }

  function onThemeMessage(ev) {
    const d = ev && ev.data;
    if (!d || d.type !== "ssx_theme") return;
    applyTheme(d.theme);
  }

  // ─────────────────────────────────────
  // Match preview + fixture snapshot (A안: /api/fixture_meta)
  // ─────────────────────────────────────
  let _fixtureMetaTimer = null;

  function getEditorCategory() { return ($("pCategory").value || "analysis").trim(); }
  function getEditorSport() { return ($("pSport").value || "").trim().toLowerCase(); }
  function getEditorFixtureKey() { return ($("pFixtureKey").value || "").trim(); }

  function hideMatchPreview() {
    const box = $("matchPreview");
    if (!box) return;
    box.style.display = "none";
    box.innerHTML = "";
  }

  function readSnapshotObj() {
    const raw = ($("pSnapshotJson").value || "").trim() || "{}";
    try { return JSON.parse(raw); } catch(e) { return {}; }
  }

  function writeSnapshotObj(obj) {
    $("pSnapshotJson").value = JSON.stringify(obj || {}, null, 2);
  }

  function snapshotHasFixtureFor(sport, fixtureKey, snapshotObj) {
    const s = snapshotObj || {};
    const f = s.fixture || null;
    if (!f) return false;
    if ((f.sport || "") !== sport) return false;
    if (String(f.fixture_key || f.fixture_id || "") !== String(fixtureKey)) return false;
    if (!f.home || !f.away) return false;
    if (!f.home.name || !f.away.name) return false;
    // ✅ 로고는 없어도 프리뷰/리스트는 보여주자(football-override 스타일)
    return true;
  }

  function renderMatchPreview(fixture) {
    const box = $("matchPreview");
    if (!box) return;

    if (!fixture || !fixture.home || !fixture.away) {
      hideMatchPreview();
      return;
    }

    const leagueName = fixture.league && fixture.league.name ? fixture.league.name : "";
    const kickoff = fixture.kickoff_utc ? String(fixture.kickoff_utc).slice(0, 16).replace("T", " ") : "";
    const top = (leagueName || kickoff)
      ? `<div class="mpTop">${escapeHtml(leagueName)}${leagueName && kickoff ? " · " : ""}${escapeHtml(kickoff)}</div>`
      : "";

    const hLogo = safeLogo(fixture.home.logo);
    const aLogo = safeLogo(fixture.away.logo);

    box.innerHTML = `
      ${top}
      <div class="mpRow">
        <div class="team left">
          <img class="logo" src="${escapeHtml(hLogo)}" alt="H" onerror="this.src='${_EMPTY_LOGO}'" />
          <div class="name" title="${escapeHtml(fixture.home.name)}">${escapeHtml(fixture.home.name)}</div>
        </div>
        <div class="vs">VS</div>
        <div class="team right">
          <img class="logo" src="${escapeHtml(aLogo)}" alt="A" onerror="this.src='${_EMPTY_LOGO}'" />
          <div class="name" title="${escapeHtml(fixture.away.name)}">${escapeHtml(fixture.away.name)}</div>
        </div>
      </div>
    `;
    box.style.display = "block";
  }


  function renderMatchPreviewFromSnapshot() {
    // analysis에서만 보여주고, 아니면 숨김
    if (getEditorCategory() !== "analysis") return hideMatchPreview();

    const sport = getEditorSport();
    const fixtureKey = getEditorFixtureKey();
    if (!sport || !fixtureKey) return hideMatchPreview();

    const snap = readSnapshotObj();
    if (!snapshotHasFixtureFor(sport, fixtureKey, snap)) return hideMatchPreview();
    renderMatchPreview(snap.fixture);
  }

  async function fetchFixtureMeta(sport, fixtureKey) {
    const qs = new URLSearchParams();
    qs.set("sport", sport);
    qs.set("fixture_key", fixtureKey);

    const r = await api(adminUrl("/api/fixture_meta?" + qs.toString()), { method: "GET" });
    setDebug(r);

    if (r.status >= 400 || !r.data || !r.data.ok) {
      return null;
    }
    return r.data.fixture || null;
  }

  function buildSnapshotFromMeta(sport, fixtureKey, fx) {
    // fx는 서버가 내려주는 fixture 객체 그대로 저장
    return {
      fixture: Object.assign({}, fx, {
        sport,
        fixture_key: fixtureKey,
      })
    };
  }

  async function ensureFixtureSnapshot(payload) {
    // analysis + sport + fixture_key일 때만
    if (!payload || payload.category !== "analysis") return payload;
    if (!payload.sport || !payload.fixture_key) return payload;

    const sport = String(payload.sport).toLowerCase();
    const fixtureKey = String(payload.fixture_key);

    const snap = payload.snapshot_json || {};
    if (snapshotHasFixtureFor(sport, fixtureKey, snap)) {
      renderMatchPreview(snap.fixture);
      return payload;
    }

    const fx = await fetchFixtureMeta(sport, fixtureKey);
    if (!fx) throw new Error("fixture_meta not found");

    const newSnap = buildSnapshotFromMeta(sport, fixtureKey, fx);
    payload.snapshot_json = newSnap;

    // textarea 동기화 + 프리뷰 렌더
    writeSnapshotObj(newSnap);
    renderMatchPreview(fx);

    // ✅ 타이틀 2줄: 경기 선택/변경 시마다 무조건 덮어쓰기
    $("pTitle").value = buildTwoLineTitleFromFixture(fx);


    return payload;

  }

  function scheduleFixturePreviewRefresh() {
    if (_fixtureMetaTimer) clearTimeout(_fixtureMetaTimer);
    _fixtureMetaTimer = setTimeout(async () => {
      // category/sport/fixtureKey 조건 맞을 때만 시도
      if (getEditorCategory() !== "analysis") return hideMatchPreview();

      const sport = getEditorSport();
      const fixtureKey = getEditorFixtureKey();
      if (!sport || !fixtureKey) return hideMatchPreview();

      // snapshot이 이미 맞으면 그걸로 표시
      const snap = readSnapshotObj();
      if (snapshotHasFixtureFor(sport, fixtureKey, snap)) {
        renderMatchPreview(snap.fixture);
        $("pTitle").value = buildTwoLineTitleFromFixture(snap.fixture);
        return;
      }


      // 아직 없으면 서버에서 가져와서 snapshot 채워주고 프리뷰 표시
      const fx = await fetchFixtureMeta(sport, fixtureKey);
      if (!fx) return hideMatchPreview();

      const newSnap = buildSnapshotFromMeta(sport, fixtureKey, fx);
      writeSnapshotObj(newSnap);
      renderMatchPreview(fx);

      // ✅ 타이틀 2줄: 경기 선택/변경 시마다 무조건 덮어쓰기
      $("pTitle").value = buildTwoLineTitleFromFixture(fx);


    }, 350);
  }

  // ─────────────────────────────────────
  // Fixture Picker Modal (Fixtures Browser)
  // ─────────────────────────────────────
  let _fxModalTimer = null;
  let _fxRows = [];

  function showFixtureModal() {
    const m = $("fixtureModal");
    if (!m) return;
    m.style.display = "flex";
    m.setAttribute("aria-hidden", "false");
  }

  function hideFixtureModal() {
    const m = $("fixtureModal");
    if (!m) return;
    m.style.display = "none";
    m.setAttribute("aria-hidden", "true");
  }

  function todayYmdLocal() {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, "0");
    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
  }

  function fxSetStatus(msg) {
    const el = $("fxStatus");
    if (el) el.textContent = msg || "";
  }

  function fxPick(obj, keys, fallback = "") {
  for (const k of keys) {
    if (!obj || obj[k] == null) continue;

    const v = obj[k];

    // primitive
    if (typeof v === "string" || typeof v === "number" || typeof v === "boolean") {
      const s = String(v).trim();
      if (s !== "") return s;
      continue;
    }

    // object -> name 우선 추출
    if (typeof v === "object") {
      // 가장 흔한 형태들
      if (v.name != null && String(v.name).trim() !== "") return String(v.name).trim();
      if (v.team && v.team.name != null && String(v.team.name).trim() !== "") return String(v.team.name).trim();
      if (v.league && v.league.name != null && String(v.league.name).trim() !== "") return String(v.league.name).trim();

      // id가 필요한 경우도 있으니 id도 지원
      if (v.id != null && String(v.id).trim() !== "") return String(v.id).trim();
      if (v.fixture_id != null && String(v.fixture_id).trim() !== "") return String(v.fixture_id).trim();
      if (v.fixtureId != null && String(v.fixtureId).trim() !== "") return String(v.fixtureId).trim();

      // 그래도 못 찾으면 빈값 처리(= [object Object] 방지)
      continue;
    }
  }
  return fallback;
}

function fxPickId(obj, keys, fallback = "") {
  for (const k of keys) {
    if (!obj || obj[k] == null) continue;
    const v = obj[k];

    // number
    if (typeof v === "number" && Number.isFinite(v)) return String(v);

    // numeric string
    if (typeof v === "string") {
      const s = v.trim();
      if (s !== "" && Number.isFinite(Number(s))) return s;
      continue;
    }

    // object: id 우선 (name은 무시)
    if (typeof v === "object") {
      if (v.id != null) {
        const s = String(v.id).trim();
        if (s !== "" && Number.isFinite(Number(s))) return s;
      }
      if (v.league_id != null) {
        const s = String(v.league_id).trim();
        if (s !== "" && Number.isFinite(Number(s))) return s;
      }
      if (v.fixture_id != null) {
        const s = String(v.fixture_id).trim();
        if (s !== "" && Number.isFinite(Number(s))) return s;
      }
    }
  }
  return fallback;
}


function fxPickLogo(row, side /* "home" | "away" */) {
  const r = row || {};
  const s = String(side || "").toLowerCase();

  // 1) flat keys
  const flat = (s === "home")
    ? (r.home_logo || r.homeLogo || r.home_team_logo)
    : (r.away_logo || r.awayLogo || r.away_team_logo);
  if (flat) return String(flat).trim();

  // 2) nested common shapes
  const t = (s === "home")
    ? (r.home || (r.teams && r.teams.home) || (r.team && r.team.home))
    : (r.away || (r.teams && r.teams.away) || (r.team && r.team.away));

  if (t) {
    if (t.logo) return String(t.logo).trim();
    if (t.team && t.team.logo) return String(t.team.logo).trim();
  }

  // 3) fallback
  return "";
}



  function openFixturePicker() {
    // sport 선택이 비어있으면 football로 기본
    if (!getEditorSport()) $("pSport").value = "football";

    // 기본값 세팅
    if ($("fxDate") && !$("fxDate").value) $("fxDate").value = todayYmdLocal();
    if ($("fxDateTo") && !$("fxDateTo").value) $("fxDateTo").value = $("fxDate").value || todayYmdLocal();
    if ($("fxTz") && !$("fxTz").value) $("fxTz").value = "Asia/Seoul";

    fxSetStatus("");
    $("fxList").innerHTML = "";
    showFixtureModal();

    // 바로 로드
    loadFixtureBrowser();
  }


  function closeFixturePicker() {
    hideFixtureModal();
  }

  // 모달 바깥 클릭하면 닫기
  (function wireModalOutsideClose() {
    const m = $("fixtureModal");
    if (!m) return;
    m.addEventListener("click", (ev) => {
      if (ev.target === m) closeFixturePicker();
    });
    window.addEventListener("keydown", (ev) => {
      if (ev.key === "Escape" && m.style.display !== "none") closeFixturePicker();
    });
  })();

  // ─────────────────────────────────────
  // Fixtures range helpers (from football_override)
  // ─────────────────────────────────────
  function normalizeLeagueIdsInput(raw) {
    const s = String(raw || "").trim();
    if (!s) return "";
    const parts = s.split(",")
      .map(x => String(x).trim())
      .filter(Boolean)
      .map(x => Number(x))
      .filter(n => Number.isFinite(n) && n > 0);

    // unique + sort
    const set = new Set(parts);
    return Array.from(set).sort((a,b)=>a-b).join(",");
  }

  function parseLeagueIdsSet(raw) {
    const norm = normalizeLeagueIdsInput(raw);
    if (!norm) return null;
    const set = new Set();
    for (const x of norm.split(",")) {
      const n = Number(String(x).trim());
      if (Number.isFinite(n) && n > 0) set.add(n);
    }
    return set.size ? set : null;
  }

  function parseYmdToUtcDate(ymd) {
    return new Date(String(ymd).trim() + "T00:00:00Z");
  }

  function fmtUtcDateToYmd(d) {
    return d.toISOString().slice(0, 10);
  }

  function enumerateYmdRange(fromYmd, toYmd, maxDays = 31) {
    const a = String(fromYmd || "").trim();
    const b = String(toYmd || "").trim();
    if (!a) return { ok:false, days:[], error:"from_date_required" };

    const fromD = parseYmdToUtcDate(a);
    const toD = parseYmdToUtcDate(b || a);

    if (!Number.isFinite(fromD.getTime()) || !Number.isFinite(toD.getTime())) {
      return { ok:false, days:[], error:"invalid_date" };
    }

    if (toD.getTime() < fromD.getTime()) {
      return { ok:false, days:[], error:"to_before_from" };
    }

    const days = [];
    let cur = fromD;
    for (let i = 0; i < maxDays; i++) {
      days.push(fmtUtcDateToYmd(cur));
      if (fmtUtcDateToYmd(cur) === fmtUtcDateToYmd(toD)) break;
      cur = new Date(cur.getTime() + 24 * 3600 * 1000);
    }

    if (days[days.length - 1] !== fmtUtcDateToYmd(toD)) {
      return { ok:false, days:[], error:"range_too_long" };
    }

    return { ok:true, days, error:"" };
  }

  function buildFixturesQuery(dateOverride) {
    const tz = ($("fxTz").value || "Asia/Seoul").trim();
    const leagueIds = normalizeLeagueIdsInput($("fxLeagueIds").value || "");

    const date = (dateOverride != null && String(dateOverride).trim() !== "")
      ? String(dateOverride).trim()
      : (($("fxDate").value || "").trim());

    const qs = new URLSearchParams();
    qs.set("date", date);
    qs.set("timezone", tz);
    if (leagueIds) qs.set("league_ids", leagueIds);
    return qs;
  }

  async function fetchFixtureBrowserRows() {
    const from = (($("fxDate").value || "").trim());
    const to = (($("fxDateTo").value || "").trim()) || from;

    if (!from) throw new Error("Date (From)를 선택하세요");

    const range = enumerateYmdRange(from, to, 31);
    if (!range.ok) throw new Error("기간 설정 오류: " + range.error + " (최대 31일)");

    const days = range.days || [];

    // fixture_id 기준 dedupe
    const map = {}; // fixture_id -> row

    for (let i = 0; i < days.length; i++) {
      const day = days[i];
      fxSetStatus(`fixtures 기간 조회중... (${i + 1}/${days.length}) ${day}`);

      const qs = buildFixturesQuery(day);
      const url = adminUrl("/api/fixtures_merged?" + qs.toString());

      const r = await api(url, { method: "GET" });
      setDebug(r);

      if (r.status >= 400 || !r.data || !r.data.ok) {
        const err = r.data ? JSON.stringify(r.data) : ("HTTP " + r.status);
        throw new Error(`fixtures_merged 로드 실패 (${day}): ` + err);
      }

      const rows = r.data.rows || [];
      for (const x of rows) {
        if (!x) continue;
        const fid = String(fxPick(x, ["fixture_id", "fixtureId", "id", "fixture"], ""));
        if (!fid) continue;
        map[fid] = x;
      }
    }

    return Object.values(map);
  }


  function getFxSearchQ() {
  return (($("fxSearch").value || "").trim().toLowerCase());
}

function filterFixtureRows(rows) {
  const q = getFxSearchQ();
  const leagueSet = parseLeagueIdsSet(($("fxLeagueIds").value || ""));

  return (rows || []).filter(r => {
    // ✅ league_ids 필터(선택된 리그만)
    if (leagueSet && leagueSet.size > 0) {
      const lid = Number(fxPickId(r, ["league_id", "leagueId", "league"], ""));
      if (!Number.isFinite(lid) || !leagueSet.has(lid)) return false;
    }

    // ✅ search 필터
    if (!q) return true;

    const text = [
      fxPick(r, ["league_name", "league", "leagueName", "competition"], ""),
      fxPick(r, ["league_country", "country"], ""),
      fxPick(r, ["league_round", "round"], ""),
      fxPick(r, ["home_name", "home", "homeTeam", "home_team"], ""),
      fxPick(r, ["away_name", "away", "awayTeam", "away_team"], ""),
      fxPick(r, ["fixture_id", "fixtureId", "id", "fixture"], ""),
    ].join(" ").toLowerCase();

    return text.includes(q);
  });
}



  // ─────────────────────────────────────
  // League pick (from loaded list) + pills
  // ─────────────────────────────────────
  let _fxLeagueNameById = {};

  function fxRefreshLeaguePick() {
    const sel = $("fxLeaguePick");
    if (!sel) return;

    const prev = (sel.value || "").trim();

    // id -> { country, league, label }
    const map = new Map();

    for (const r of (_fxRows || [])) {
      const idStr = fxPickId(r, ["league_id", "leagueId", "league"], "");
      const idNum = Number(String(idStr).trim());
      if (!Number.isFinite(idNum) || idNum <= 0) continue;

      const league = (fxPick(r, ["league_name", "leagueName", "league"], "") || ("League " + idNum)).trim();
      const country = (fxPick(r, ["league_country", "country"], "") || "").trim();

      const base = country ? `${country} · ${league}` : league;
      const label = `${base} (${idNum})`;

      // 같은 id는 마지막 것으로 덮어쓰기
      map.set(idNum, { country, league, label });
    }

    const entries = Array.from(map.entries()).sort((a, b) => {
      const A = a[1] || {};
      const B = b[1] || {};
      const c1 = String(A.country || "").localeCompare(String(B.country || ""));
      if (c1 !== 0) return c1;

      const c2 = String(A.league || "").localeCompare(String(B.league || ""));
      if (c2 !== 0) return c2;

      return a[0] - b[0];
    });

    // pills에서 사용할 “label(이미 id 포함)”로 저장
    _fxLeagueNameById = {};
    for (const [id, obj] of entries) _fxLeagueNameById[id] = obj.label;

    sel.innerHTML =
      `<option value="">(전체 리그)</option>` +
      entries.map(([id, obj]) =>
        `<option value="${escapeHtml(String(id))}">${escapeHtml(obj.label)}</option>`
      ).join("");

    // 이전 선택 유지(가능하면)
    if (prev && sel.querySelector(`option[value="${CSS.escape(prev)}"]`)) sel.value = prev;
    else sel.value = "";

    fxUpdateLeaguePills();
  }



  function fxUpdateLeaguePills() {
    const box = $("fxLeaguePills");
    const input = $("fxLeagueIds");
    if (!box || !input) return;

    const set = parseLeagueIdsSet(input.value || "");
    box.innerHTML = "";

    if (!set || set.size === 0) return;

    const ids = Array.from(set).sort((a,b)=>a-b);
    for (const id of ids) {
      const label = _fxLeagueNameById[id] || ("League " + id + " (" + id + ")");

      const pill = document.createElement("div");
      pill.className = "fxPillGroup";
      pill.innerHTML = `
        <span>${escapeHtml(label)}</span>
        <span class="fxPillX" title="remove">×</span>
      `;

      pill.querySelector(".fxPillX").onclick = () => {
        const cur = parseLeagueIdsSet(input.value || "") || new Set();
        cur.delete(id);
        input.value = Array.from(cur).sort((a,b)=>a-b).join(",");
        fxUpdateLeaguePills();
        renderFixtureBrowserList(filterFixtureRows(_fxRows));
      };
      box.appendChild(pill);
    }
  }

  function fxAddLeagueFromPick() {
    const sel = $("fxLeaguePick");
    const input = $("fxLeagueIds");
    if (!sel || !input) return;

    const v = (sel.value || "").trim();
    if (!v) return;

    const n = Number(v);
    if (!Number.isFinite(n) || n <= 0) return;

    const set = parseLeagueIdsSet(input.value || "") || new Set();
    set.add(n);
    input.value = Array.from(set).sort((a,b)=>a-b).join(",");

    fxUpdateLeaguePills();
    renderFixtureBrowserList(filterFixtureRows(_fxRows));
  }

  function fxRemoveLeagueFromPick() {
    const sel = $("fxLeaguePick");
    const input = $("fxLeagueIds");
    if (!sel || !input) return;

    const v = (sel.value || "").trim();
    if (!v) return;

    const n = Number(v);
    if (!Number.isFinite(n) || n <= 0) return;

    const set = parseLeagueIdsSet(input.value || "") || new Set();
    set.delete(n);
    input.value = Array.from(set).sort((a,b)=>a-b).join(",");

    fxUpdateLeaguePills();
    renderFixtureBrowserList(filterFixtureRows(_fxRows));
  }

  function fxClearLeagueFilter() {
    const sel = $("fxLeaguePick");
    const input = $("fxLeagueIds");
    if (input) input.value = "";
    if (sel) sel.value = "";
    fxUpdateLeaguePills();
    renderFixtureBrowserList(filterFixtureRows(_fxRows));
  }





  function renderFixtureBrowserList(rows) {
  const box = $("fxList");
  box.innerHTML = "";

  const viewRows = rows || [];

  for (const r of viewRows) {

    const fixtureId = String(fxPick(r, ["fixture_id", "fixtureId", "id", "fixture"], ""));

    const league = String(fxPick(r, ["league_name", "league", "leagueName", "competition"], ""));
    const kickoffRaw = fxPick(r, ["kickoff", "kickoff_utc", "date_utc", "date", "time"], "");
    const kickoff = kickoffRaw ? String(kickoffRaw) : "";

    const home = String(fxPick(r, ["home_name", "home", "homeTeam", "home_team"], ""));
    const away = String(fxPick(r, ["away_name", "away", "awayTeam", "away_team"], ""));
    const status = String(fxPick(r, ["status", "short_status", "state"], "OTHER"));

    const hg = fxPick(r, ["home_goals", "homeGoals", "goals_home", "home_score"], null);
    const ag = fxPick(r, ["away_goals", "awayGoals", "goals_away", "away_score"], null);
    const scoreTxt = (hg != null && ag != null) ? `${hg} : ${ag}` : "- : -";

    const hLogo = safeLogo(fxPickLogo(r, "home"));
    const aLogo = safeLogo(fxPickLogo(r, "away"));

    const div = document.createElement("div");
    div.className = "fxItem";
    div.innerHTML = `
      <div class="fxLeft">
        <div class="fxMeta">
          <span class="fxPill">${escapeHtml(status)}</span>
          <span class="fxPill">#${escapeHtml(fixtureId)}</span>
          ${league ? `<span>${escapeHtml(league)}</span>` : ""}
          ${kickoff ? `<span>· ${escapeHtml(String(kickoff).slice(0, 16).replace("T"," "))}</span>` : ""}
        </div>

        <div class="fxTeams" title="${escapeHtml(home + " vs " + away)}">
          <img class="fxLogo" src="${escapeHtml(hLogo)}" alt="" onerror="this.src='${_EMPTY_LOGO}'" />
          <div class="fxTeamName">${escapeHtml(home)}</div>
          <div class="fxVs">vs</div>
          <div class="fxTeamName" style="text-align:right;">${escapeHtml(away)}</div>
          <img class="fxLogo" src="${escapeHtml(aLogo)}" alt="" onerror="this.src='${_EMPTY_LOGO}'" />
        </div>
      </div>

      <div class="fxRight">
        <div class="fxScore">${escapeHtml(scoreTxt)}</div>
        <div style="opacity:.75;">선택</div>
      </div>
    `;

    div.onclick = () => {
      if (!fixtureId) return alert("fixture_id를 찾을 수 없습니다. 서버 응답 필드 확인 필요");
      if (!getEditorSport()) $("pSport").value = "football"; // 최소: 비어있으면 football
      $("pFixtureKey").value = fixtureId;
      scheduleFixturePreviewRefresh();
      closeFixturePicker();

    };

    box.appendChild(div);
  }
}




  async function loadFixtureBrowser() {
  fxSetStatus("fixtures 불러오는 중...");
  $("fxList").innerHTML = "";
  try {
    const rows = await fetchFixtureBrowserRows();

    // ✅ 원본 전체 rows는 보관
    _fxRows = rows || [];

    // ✅ NEW: 로드된 목록 기준으로 league 드롭다운 갱신
    fxRefreshLeaguePick();

    // ✅ 필터(league/search) 적용 후 렌더
    const filtered = filterFixtureRows(_fxRows);
    renderFixtureBrowserList(filtered);

    fxSetStatus(`완료: 전체 ${_fxRows.length}개 · 표시 ${filtered.length}개 (클릭하면 Fixture Key에 자동 입력)`);
  } catch (e) {
    fxSetStatus("");
    alert(String(e.message || e));
  }
}




  function scheduleFixtureBrowserReload() {
    if (_fxModalTimer) clearTimeout(_fxModalTimer);
    _fxModalTimer = setTimeout(() => loadFixtureBrowser(), 350);
  }

  

  async function savePost() {
    let payload = null;
    try {
      payload = buildPayload();
    } catch (e) {
      return alert(String(e.message || e));
    }

    if (!payload.title) return alert("title은 필수입니다.");
    if (!payload.content_md) return alert("content_md는 필수입니다.");

    // ✅ analysis 글 + (sport, fixture_key) 있으면 저장 전에 snapshot_json 자동 채움
    try {
      payload = await ensureFixtureSnapshot(payload);
    } catch (e) {
      return alert("매치 메타 로드 실패: " + String(e.message || e));
    }

    if (payload.status === "published" && !payload.publish_at) {
      payload.publish_at = new Date().toISOString();
      $("pPublishAt").value = isoToDatetimeLocal(payload.publish_at);
    }

    const isNew = !selectedId;
    const ok = confirm(isNew ? "새 글을 저장할까요?" : ("글을 저장(업데이트)할까요? (#" + selectedId + ")"));
    if (!ok) return;

    setSaveHint("저장 중...");
    const path = isNew
      ? adminUrl("/api/board/posts")
      : adminUrl("/api/board/posts/" + selectedId);

    const method = isNew ? "POST" : "PUT";

    const r = await api(path, {
      method,
      body: JSON.stringify(payload),
    });
    setDebug(r);

    if (r.status >= 400 || !r.data || !r.data.ok) {
      setSaveHint("");
      alert("저장 실패: " + JSON.stringify(r.data));
      return;
    }

    if (isNew && r.data.id != null) {
      selectedId = String(r.data.id);
      $("pId").value = selectedId;
      setSaveHint("저장 완료: #" + selectedId);
      await loadPosts();
      await selectPost(selectedId);
    } else {
      setSaveHint("저장 완료");
      await loadPosts();
      if (selectedId) await selectPost(selectedId);
    }
  }


  async function deletePost() {
    if (!selectedId) return alert("삭제할 글을 먼저 선택하세요.");
    const ok = confirm("정말 삭제할까요? (#" + selectedId + ")");
    if (!ok) return;

    setSaveHint("삭제 중...");
    const r = await api(adminUrl("/api/board/posts/" + selectedId), { method: "DELETE" });
    setDebug(r);

    if (r.status >= 400 || !r.data || !r.data.ok) {
      setSaveHint("");
      alert("삭제 실패: " + JSON.stringify(r.data));
      return;
    }

    setSaveHint("삭제 완료");
    clearEditor();
    await loadPosts();
  }

  // Init
  $("pathHint").textContent = location.pathname;

  // ✅ admin.html -> iframe 테마 동기화
  window.addEventListener("message", onThemeMessage);

  // ✅ 입력 변화 시 프리뷰 자동 갱신(디바운스)
  $("pCategory").addEventListener("change", () => {
    renderMatchPreviewFromSnapshot();
    scheduleFixturePreviewRefresh();
  });
  $("pSport").addEventListener("change", () => scheduleFixturePreviewRefresh());
  $("pFixtureKey").addEventListener("input", () => scheduleFixturePreviewRefresh());
  $("pSnapshotJson").addEventListener("input", () => renderMatchPreviewFromSnapshot());

  // ✅ Fixture Browser inputs -> debounce reload
  $("fxDate").addEventListener("change", () => scheduleFixtureBrowserReload());
  $("fxDateTo").addEventListener("change", () => scheduleFixtureBrowserReload());
  $("fxTz").addEventListener("change", () => scheduleFixtureBrowserReload());

  // fxLeagueIds는 hidden이고 +/-/ALL로만 변경되므로 input 리스너 불필요
  $("fxSearch").addEventListener("input", () => {
    const filtered = filterFixtureRows(_fxRows);
    renderFixtureBrowserList(filtered);
    fxSetStatus(`완료: 전체 ${_fxRows.length}개 · 표시 ${filtered.length}개 (클릭하면 Fixture Key에 자동 입력)`);
  });




  renderLangBox();
  loadPosts();


</script>
</body>
</html>
