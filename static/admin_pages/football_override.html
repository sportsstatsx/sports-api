<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>SportsStatsX Admin</title>
  <style>
    body { font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif; margin: 18px; }
    .top { display:flex; justify-content:space-between; align-items:flex-end; gap:12px; flex-wrap:wrap; }
    .muted { color:#666; font-size:12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    .card { border:1px solid #ddd; border-radius:10px; padding:14px; }
    .card h2 { margin:0 0 10px 0; font-size: 16px; }
    input, textarea, button, select { font-size: 14px; }
    input, textarea, select {
      width: 100%; box-sizing:border-box; padding:10px; border-radius:8px; border:1px solid #ccc;
      background:#fff;
    }
    textarea { min-height: 140px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    button { padding:10px 12px; border-radius:8px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    button.primary { border-color:#000; }
    button.danger { border-color:#d33; color:#d33; }
    button.soft { opacity:0.9; }
    .grid { display:grid; grid-template-columns: 1.1fr 0.9fr; gap:12px; align-items:start; }
    @media (max-width: 1100px) { .grid { grid-template-columns: 1fr; } }

    .listWrap{
  max-height:560px;
  overflow:auto;
  border:1px solid var(--border2);
  border-radius:10px;
  background: var(--panel);
}

.item{
  padding:10px 12px;
  border-bottom:1px solid var(--border2);
  cursor:pointer;
  display:flex;
  gap:10px;
  align-items:flex-start;
  background: transparent;
}

.item:hover{
  background: var(--panel2);
}

.item.sel{
  background: var(--sel);
}

.badge{
  display:inline-block;
  padding:2px 8px;
  border:1px solid var(--border2);
  border-radius:999px;
  font-size:12px;
  color: var(--text);
  background: transparent;
}

.item.hidden{ opacity:0.55; }

.badge.ovr{ border-color: var(--text); }
.badge.hid{ border-color: var(--danger); color: var(--danger); }

.right{ margin-left:auto; text-align:right; }
.small{ font-size:12px; }
.k{ font-weight:600; }
.ok{ color: var(--ok); }
.bad{ color: var(--danger); }

.tabs{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  margin-top:10px;
}

.tabbtn{
  padding:8px 10px;
  border-radius:999px;
  border:1px solid var(--border2);
  background: var(--panel);
  color: var(--text);
  cursor:pointer;
  font-size:12px;
}

.tabbtn.active{
  border-color: var(--text);
}

.tabpane{ display:none; margin-top:10px; }
.tabpane.active{ display:block; }

table{ width:100%; border-collapse:collapse; }

th, td{
  border-bottom:1px solid var(--border2);
  padding:8px;
  text-align:left;
  vertical-align:top;
}

        /* ---- Event Editor ---- */
    .subcard{
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px;
      background:var(--panel);
      transition: background .12s ease, border-color .12s ease;
    }
    .subcard:hover{
      /* 다크에서 hover 시 “하얗게” 튀는 케이스 방지: 배경은 유지하고 테두리만 강조 */
      border-color:var(--border2);
      background:var(--panel);
    }



    .subcard h3 { margin:0 0 10px 0; font-size:14px; }
    .mini { font-size:12px; color:var(--muted); }

    .btnsm{
      padding:6px 10px;
      border-radius:8px;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      cursor:pointer;
      font-size:12px;
      transition: background .12s ease, border-color .12s ease;
    }
    .btnsm:hover{
      background:var(--panel2);
      border-color:var(--border2);
    }
    .btnsm.primary { border-color: var(--accent); }
    .btnsm.danger  { border-color: var(--danger); color: var(--danger); }

    .pill{
      display:inline-block;
      padding:2px 8px;
      border:1px solid var(--border2);
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
      background:transparent;
    }

    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width: 1100px) { .grid2 { grid-template-columns: 1fr; } }

    .evtTable input, .evtTable select{
      padding:8px;
      font-size:12px;
      background:var(--panel);
      color:var(--text);
      border:1px solid var(--border);
    }
    .evtTable th, .evtTable td{
      border-bottom:1px solid var(--border);
    }
    .evtTable td { padding:6px; }


    /* ─────────────────────────────────────
   Theme (shared)
   ───────────────────────────────────── */
:root{
  --bg:#ffffff;
  --panel:#ffffff;
  --panel2:#fafafa;
  --text:#111214;
  --muted:#666;
  --border:#ddd;
  --border2:#eee;
  --danger:#d33;
  --ok:#0a7;

  /* ✅ 추가: UI 공통 */
  --accent: var(--text);
  --sel:#f3f6ff;     /* 선택 item 배경(라이트) */
}
html[data-theme="dark"]{
  --bg:#0b0c0f;
  --panel:#12141a;
  --panel2:#0f1116;
  --text:#f1f3f5;
  --muted:#9aa3ad;
  --border:rgba(241,243,245,0.14);
  --border2:rgba(241,243,245,0.10);
  --danger:#ff6b6b;
  --ok:#53e0b2;

  /* ✅ 추가: UI 공통 */
  --accent: var(--text);
  --sel: rgba(241,243,245,0.06); /* 선택 item 배경(다크) */
}


body{ background:var(--bg) !important; color:var(--text) !important; }
.muted{ color:var(--muted) !important; }
.card{ background:var(--panel) !important; border-color:var(--border) !important; }

input, textarea, select{
  background:var(--panel) !important;
  color:var(--text) !important;
  border-color:var(--border) !important;
}
button{
  background:var(--panel) !important;
  color:var(--text) !important;
  border-color:var(--border) !important;
}
button.primary{ border-color:var(--text) !important; }
button.danger{ border-color:var(--danger) !important; color:var(--danger) !important; }

pre{
  background:var(--panel2) !important;
  border-color:var(--border2) !important;
  color:var(--text) !important;
}
.ok{ color:var(--ok) !important; }
.bad{ color:var(--danger) !important; }

/* ─────────────────────────────────────
   Compact + App-like tweaks
   ───────────────────────────────────── */

body{
  margin: 12px !important;
  font-size: 13px;
}

h1{ font-size: 22px; }
.card{ padding: 12px !important; border-radius: 14px !important; }
.card h2{ font-size: 14px !important; margin: 0 0 8px 0 !important; }

.row{ gap:10px !important; }
.tabs{ gap:6px !important; margin-top:8px !important; }

input, textarea, button, select{ font-size: 13px !important; }
input, textarea, select{ padding: 8px !important; border-radius: 10px !important; }
button{ padding: 8px 10px !important; border-radius: 10px !important; }

.listWrap{
  max-height: 520px !important; /* 살짝 줄여서 더 “앱”처럼 */
}

/* fixtures item 더 촘촘하게 */
.item{ padding: 9px 10px !important; gap:10px !important; }
.badge{ font-size: 11px !important; padding: 2px 7px !important; }

/* Event table도 컴팩트 */
.evtTable td{ padding: 5px !important; }
.evtTable input, .evtTable select{
  padding: 7px !important;
  font-size: 12px !important;
  border-radius: 10px !important;
}

/* ─────────────────────────────────────
   Dark scrollbar fix (white scrollbar 제거)
   ───────────────────────────────────── */

/* Firefox */
*{
  scrollbar-width: thin;
}
html[data-theme="dark"] *{
  scrollbar-color: rgba(241,243,245,0.25) rgba(241,243,245,0.06);
}
html:not([data-theme="dark"]) *{
  scrollbar-color: rgba(0,0,0,0.25) rgba(0,0,0,0.06);
}

/* Chromium / WebKit */
::-webkit-scrollbar{ width: 10px; height: 10px; }
::-webkit-scrollbar-track{ background: rgba(0,0,0,0.06); }
::-webkit-scrollbar-thumb{
  background: rgba(0,0,0,0.22);
  border-radius: 999px;
  border: 2px solid rgba(0,0,0,0.06);
}
html[data-theme="dark"] ::-webkit-scrollbar-track{ background: rgba(241,243,245,0.06); }
html[data-theme="dark"] ::-webkit-scrollbar-thumb{
  background: rgba(241,243,245,0.20);
  border: 2px solid rgba(241,243,245,0.06);
}
html[data-theme="dark"] ::-webkit-scrollbar-thumb:hover{ background: rgba(241,243,245,0.28); }

/* ─────────────────────────────────────
   Help Tooltip ( ! 아이콘 )
   ───────────────────────────────────── */
.helpIcon{
  margin-left:8px;
  width:18px;
  height:18px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  border-radius:999px;
  border:1px solid var(--border2);
  background:transparent;
  color:var(--muted);
  font-size:12px;
  font-weight:700;
  line-height:1;
  cursor:pointer;
  user-select:none;
}
.helpIcon:hover{
  border-color:var(--border);
  color:var(--text);
  background:var(--panel2);
}

.helpPop{
  position:fixed;
  z-index:99999;
  max-width:min(420px, calc(100vw - 24px));
  min-width:260px;
  background:var(--panel);
  color:var(--text);
  border:1px solid var(--border);
  border-radius:14px;
  box-shadow: 0 18px 60px rgba(0,0,0,0.35);
  padding:12px 12px 10px 12px;
}
.helpPop .hTitle{
  font-size:13px;
  font-weight:800;
  margin:0 0 8px 0;
  display:flex;
  justify-content:space-between;
  gap:10px;
  align-items:center;
}
.helpPop .hClose{
  border:1px solid var(--border2);
  background:transparent;
  color:var(--muted);
  border-radius:10px;
  padding:5px 8px;
  cursor:pointer;
  font-size:12px;
}
.helpPop .hClose:hover{
  background:var(--panel2);
  color:var(--text);
  border-color:var(--border);
}
.helpPop .hBody{
  font-size:12px;
  line-height:1.45;
  color:var(--text);
  white-space:pre-line;
}
.helpPop .hHint{
  margin-top:8px;
  font-size:11px;
  color:var(--muted);
}


/* ─────────────────────────────────────
   Fixtures filters clean layout (no clipping / nice wrapping)
   ───────────────────────────────────── */

.fxFilters{
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap:12px;
  align-items:stretch; /* ✅ 칸 높이 맞추고 내부에서 정렬 */
}

/* ✅ League Filter는 “전체 폭”으로 내려서 2번째 줄 고정 */
.fxLeagueBlock{
  grid-column: 1 / -1;
}


/* 각 칸: label + control 을 안정적으로 스택 */
.fxFilters > div{
  display:flex;
  flex-direction:column;
  gap:6px;
  min-width:0;
}

/* ✅ 라벨: 2줄까지 자연 줄바꿈 + ! 아이콘 포함해도 안 겹치게 */
.fxFilters label{
  margin:0;
  line-height:1.25;
  min-height:32px;          /* 한 줄/두 줄 모두 안정적인 높이 */
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:8px;

  white-space:normal;       /* ✅ nowrap 제거 */
  overflow:hidden;          /* ✅ 너무 길면 2줄 넘어가는 것 방지용 (아래 clamp와 함께) */

  /* ✅ 2줄까지만 보여주고 나머진 잘라냄 */
  display:-webkit-box;
  -webkit-line-clamp:2;
  -webkit-box-orient:vertical;
}

/* label 안에 들어가는 ! 아이콘 정렬 */
.fxFilters label .helpIcon{
  margin-left:0;
  flex:0 0 auto;
  align-self:flex-start;
}

/* 컨트롤 높이 통일 */
.fxFilters input,
.fxFilters select{
  min-height:36px;
  box-sizing:border-box;
}

/* Actions: 기본은 2열, 좁으면 1열로 */
.fxBtnRow{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:8px;
  margin-top:auto;
}
.fxBtnRow button{
  min-height:36px;
  display:flex;
  align-items:center;
  justify-content:center;
}

/* League: 기본은 한 줄(셀렉트 + 버튼들), 좁으면 세로로 */
.leagueBar{
  display:grid;
  grid-template-columns: 1fr auto;
  gap:8px;
  align-items:stretch;
}
.leagueBar select{ min-width:0; }

.leagueBtns{
  display:flex;
  gap:6px;
  align-items:stretch;
  flex-wrap:nowrap;
}
.leagueBtns .btnsm{
  min-height:36px;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:0 10px;
}

/* pills 영역: 줄바꿈 안정 */
.leaguePills{
  margin-top:6px;
  min-height:18px;
  display:flex;
  flex-wrap:wrap;
  gap:6px;
}
.leaguePills .pill{
  font-size:11px;
  padding:2px 8px;
  border-radius:999px;
  border:1px solid var(--border2);
  color: var(--muted);
  background: transparent;
}

/* ✅ 화면이 좁아지면(겹침 방지) 필터/리그/버튼을 세로 스택 */
@media (max-width: 760px){
  .fxFilters{ grid-template-columns: 1fr; }

  .fxBtnRow{ grid-template-columns: 1fr; }   /* 불러오기 / OVR 버튼 세로 */

  .leagueBar{ grid-template-columns: 1fr; }  /* 리그 셀렉트 위, 버튼 아래 */
  .leagueBtns{ flex-wrap:wrap; }             /* + − ALL 줄바꿈 허용 */
  .leagueBtns .btnsm{ flex:1 1 60px; }       /* 버튼이 너무 작게 찌그러지는 것 방지 */
}


/* ─────────────────────────────────────
   Layout sanity fixes (no overlap / no clipping)
   ───────────────────────────────────── */

/* ✅ 상단 영역: 스크롤 시 겹침 방지 + 시각적으로 분리 */
.top{
  position: sticky;
  top: 0;
  z-index: 200;
  background: var(--bg);
  border-bottom: 1px solid var(--border2);

  /* body margin(12px)와 맞춰 header가 “바”처럼 보이게 */
  margin: -12px -12px 12px -12px;
  padding: 10px 12px;
}

/* ✅ 2컬럼 그리드: 너무 줄어들면 겹치지 말고 자동 스택 */
.grid{
  grid-template-columns: minmax(560px, 1.15fr) minmax(520px, 0.85fr);
  gap: 14px;
}
@media (max-width: 1220px){
  .grid{ grid-template-columns: 1fr; }
}

/* ✅ 카드 내부 overflow로 “글 잘림/겹침” 나는 것 방지 */
.card{
  min-width: 0;
  overflow: hidden;
}

/* ✅ pre/textarea: 스크롤 영역으로 고정해서 레이아웃 밀림 방지 */
pre.mono{
  white-space: pre;
  overflow: auto;
  max-height: 360px;
  padding: 10px;
  border: 1px solid var(--border2);
  border-radius: 12px;
}
textarea{
  max-height: 320px;
  resize: vertical;
}

/* ✅ 탭 버튼: 내부 요소(! 아이콘 포함) 때문에 줄/겹침 나지 않게 */
.tabs{ gap: 8px; }
.tabbtn{
  display: inline-flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;
  max-width: 100%;
}

/* ✅ 리스트 아이템: flex 대신 grid로 바꿔서 좌/우가 절대 겹치지 않게 */
.item{
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 12px;
  align-items: start;
}
@media (max-width: 560px){
  .item{ grid-template-columns: 1fr; }
}

/* 좌측(팀/리그) 영역은 줄어들어도 안전하게 말줄임 */
.fxTeams{
  display: flex;
  gap: 10px;
  align-items: center;
  min-width: 0;
}
.fxTeam{
  display: flex;
  gap: 6px;
  align-items: center;
  min-width: 0;
}
.fxTeamName{
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 260px;
}
@media (max-width: 560px){
  .fxTeamName{ max-width: 160px; }
}
.fxLeagueLine{
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* 우측(배지/스코어) 영역: 최소폭 확보 + 줄바꿈/정렬 안정화 */
.fxRight{
  min-width: 170px;
  text-align: right;
}
@media (max-width: 560px){
  .fxRight{ text-align: left; }
}
.fxBadges{
  display: flex;
  gap: 6px;
  justify-content: flex-end;
  flex-wrap: wrap;
}
@media (max-width: 560px){
  .fxBadges{ justify-content: flex-start; }
}
.fxScore{
  margin-top: 6px;
  font-size: 14px;
  font-weight: 700;
}

/* ✅ 버튼들: 한 줄 과밀 방지(자동 그리드) */
.btnGrid{
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
  gap: 8px;
}
.btnGrid button{
  width: 100%;
  min-height: 36px;
}

/* row 안쪽 아이템이 폭 부족으로 튀는 케이스 방지 */
.row > div{ min-width: 0; }


  </style>
</head>
<body>
  <div class="top">
    <div>
      <h1 style="margin:0 0 6px 0;">SportsStatsX Admin</h1>
      <div class="muted">
  경로: <span id="adminPathText" class="mono"></span> · API 헤더: <span class="mono">X-Admin-Token</span> 필요
</div>

    </div>
    <div class="muted" id="statusLine"></div>
  </div>

  <div class="grid" style="margin-top:14px;">
    <!-- LEFT: Fixtures browser -->
    <div class="card">
      <h2 data-help="fxBrowser">Fixtures Browser</h2>

      <div class="fxFilters">
        <div>
          <label class="muted" data-help="fxDateFrom">Date (From)</label>
          <input id="fxDate" type="date"/>
        </div>

        <div>
          <label class="muted" data-help="fxDateTo">Date (To)</label>
          <input id="fxDateTo" type="date"/>
        </div>

        <div>
          <label class="muted" data-help="fxTz">Timezone</label>
          <select id="fxTz">
            <option value="Asia/Seoul">Asia/Seoul</option>
            <option value="UTC">UTC</option>
            <option value="Europe/London">Europe/London</option>
            <option value="America/New_York">America/New_York</option>
            <option value="America/Los_Angeles">America/Los_Angeles</option>
          </select>
        </div>

                <div class="fxLeagueBlock">
          <label class="muted" data-help="fxLeagueFilter">League Filter (from loaded list)</label>

          <div class="leagueBar">
            <select id="fxLeaguePick">
              <option value="">(전체 리그)</option>
            </select>

            <div class="leagueBtns">
              <button class="btnsm" type="button" onclick="fxAddLeagueFromPick()" data-help="btnFxLeagueAdd">+</button>
              <button class="btnsm" type="button" onclick="fxRemoveLeagueFromPick()" data-help="btnFxLeagueRemove">−</button>
              <button class="btnsm" type="button" onclick="fxClearLeagueFilter()" data-help="btnFxLeagueAll">ALL</button>
            </div>

          </div>

          <div id="fxLeaguePills" class="leaguePills"></div>

          <!-- ✅ 기능 유지용: 실제 필터 값은 이 hidden input에 유지 -->
          <input id="fxLeagueIds" type="hidden" />
        </div>


        <div>
          <label class="muted" data-help="fxSearch">Search (team/league)</label>
          <input id="fxSearch" placeholder="예: Arsenal / LaLiga"/>
        </div>

        <div>
          <label class="muted" data-help="fxActions">Actions</label>
          <div class="fxBtnRow">
            <button class="primary" onclick="loadFixtures()" data-help="btnLoadFixtures">불러오기</button>
            <button id="btnOverridesOnly" onclick="loadOverridesOnly()" data-help="btnOverridesOnly">OVR만 보기</button>
          </div>

        </div>
      </div>


      <div class="muted" style="margin-top:10px;" id="fxHint"></div>

      <div class="listWrap" style="margin-top:10px;">
        <div id="fxList"></div>
      </div>

      <div class="tabs">
        <button class="tabbtn active" id="tab_now_btn" onclick="showTab('now')" data-help="tabNow">현재(노출)</button>
        <button class="tabbtn" id="tab_raw_btn" onclick="showTab('raw')" data-help="tabRaw">원본(raw)</button>
        <button class="tabbtn" id="tab_patch_btn" onclick="showTab('patch')" data-help="tabPatch">override patch</button>
        <button class="tabbtn" id="tab_diff_btn" onclick="showTab('diff')" data-help="tabDiff">diff</button>
        <button class="tabbtn" id="tab_bundle_raw_btn" onclick="showTab('bundle_raw')" data-help="tabBundleRaw">bundle(raw)</button>
        <button class="tabbtn" id="tab_bundle_merged_btn" onclick="showTab('bundle_merged')" data-help="tabBundleMerged">bundle(merged)</button>
        <button class="tabbtn" id="tab_bundle_diff_btn" onclick="showTab('bundle_diff')" data-help="tabBundleDiff">bundle diff</button>
      </div>


      <div class="tabpane active" id="tab_now">
        <div class="muted">선택된 경기(override 반영 결과)</div>
        <pre class="mono" id="fxPreviewNow">{}</pre>
      </div>

      <div class="tabpane" id="tab_raw">
        <div class="muted">선택된 경기(override 미적용 원본)</div>
        <pre class="mono" id="fxPreviewRaw">{}</pre>
        <div class="muted" style="margin-top:8px;" id="rawHint"></div>
      </div>

      <div class="tabpane" id="tab_patch">
        <div class="muted">현재 override patch</div>
        <pre class="mono" id="fxPreviewPatch">{}</pre>
      </div>

      <div class="tabpane" id="tab_diff">
        <div class="muted">원본(raw) → 현재(노출) 변경 요약</div>
        <pre class="mono" id="fxPreviewDiff">[]</pre>
      </div>

      <div class="tabpane" id="tab_bundle_raw">
        <div class="muted">선택된 경기(bundle 원본: override 미적용)</div>
        <pre class="mono" id="bundlePreviewRaw">{}</pre>
      </div>

      <div class="tabpane" id="tab_bundle_merged">
        <div class="muted">선택된 경기(bundle merged: override 적용)</div>
        <pre class="mono" id="bundlePreviewMerged">{}</pre>
      </div>

      <div class="tabpane" id="tab_bundle_diff">
        <div class="muted">bundle(raw) → bundle(merged) 변경 요약</div>
        <pre class="mono" id="bundlePreviewDiff">[]</pre>
      </div>
      
    </div>

    <!-- RIGHT: Editor + logs -->
    <div class="row" style="align-items:stretch;">
      <div class="card" style="flex: 1 1 520px;">
        <h2 data-help="ovEditor">Override Editor</h2>

        <!-- ✅ 선택 경기 요약(앱처럼 한눈에) -->
        <div id="selSummary" class="subcard" style="margin:8px 0 10px 0; display:none;">
          <div style="display:flex; justify-content:space-between; gap:10px; align-items:flex-start;">
            <div style="min-width:0;">
              <div class="mini muted mono" id="selSummaryMeta"></div>
              <div style="display:flex; gap:10px; align-items:center; margin-top:6px; flex-wrap:wrap;">
                <div style="display:flex; gap:6px; align-items:center; min-width:0;">
                  <img id="selHomeLogo" src="" style="width:18px;height:18px;border-radius:4px; display:none;">
                  <span class="k" id="selHomeName" style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:240px;"></span>
                </div>
                <span class="mono k" id="selScore" style="font-size:16px;"></span>
                <div style="display:flex; gap:6px; align-items:center; min-width:0;">
                  <img id="selAwayLogo" src="" style="width:18px;height:18px;border-radius:4px; display:none;">
                  <span class="k" id="selAwayName" style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:240px;"></span>
                </div>
              </div>
            </div>
            <div style="text-align:right;">
              <div id="selBadges"></div>
              <div class="mini muted mono" id="selHt"></div>
            </div>
          </div>
        </div>


        <div class="row">
          <div style="flex: 1 1 220px;">
            <label class="muted" data-help="fixtureId">Fixture ID</label>
            <input id="fixtureId" placeholder="예: 123456"/>
          </div>
          <div style="flex: 1 1 220px;">
            <label class="muted" data-help="quickActions">Quick actions</label>

            <div class="btnGrid">
              <button onclick="getOverride()" data-help="btnGetOverride">조회</button>
              <button class="danger" onclick="deleteOverride()" data-help="btnDeleteOverride">삭제(원복)</button>
              <button onclick="hideFixture()" data-help="btnHideFixture">숨김(hidden=true)</button>
              <button onclick="unhideFixture()" data-help="btnUnhideFixture">숨김해제(hidden=false)</button>
            </div>
          </div>

        </div>

        <div style="margin-top:10px;" class="muted">Quick Edit → Patch 생성</div>
        <div class="row">
          <div style="flex:1 1 220px;">
            <label class="muted" data-help="qeVenue">Venue</label>
            <input id="qeVenue" placeholder="venue_name"/>
          </div>
          <div style="flex:1 1 220px;">
            <label class="muted" data-help="qeRound">League Round</label>
            <input id="qeRound" placeholder="league_round"/>
          </div>
        </div>

        <div class="row">
          <div style="flex:1 1 220px;">
            <label class="muted" data-help="qeStatusLong">Status Long</label>
            <input id="qeStatusLong" placeholder="status_long"/>
          </div>
          <div style="flex:1 1 220px;">
            <label class="muted" data-help="qeElapsed">Elapsed</label>
            <input id="qeElapsed" type="number" placeholder="elapsed (ex: 57)"/>
          </div>
        </div>

                <div class="row">
  <div style="flex:1 1 220px;">
    <label class="muted" data-help="qeStatusGroup">Status Group</label>

    <!-- ✅ 프리셋 드롭다운(클릭하면 항상 선택지 표시) + 직접 입력(input)은 기존 id 유지 -->
    <div class="row" style="gap:8px;">
      <div style="flex:0 0 170px;">
        <select id="qeStatusGroupPreset">
          <option value="">(preset)</option>
          <option value="UPCOMING">UPCOMING</option>
          <option value="INPLAY">INPLAY</option>
          <option value="FINISHED">FINISHED</option>
          <option value="PST">PST</option>
          <option value="SUSP">SUSP</option>
          <option value="CANC">CANC</option>
          <option value="TBD">TBD</option>
        </select>
      </div>
      <div style="flex:1 1 auto;">
        <input id="qeStatusGroup" placeholder="(keep) 또는 직접 입력" autocomplete="off" inputmode="latin"/>
      </div>
    </div>
  </div>

  <div style="flex:1 1 220px;">
    <label class="muted" data-help="qeStatus">Status</label>

    <!-- ✅ 프리셋 드롭다운 + 직접 입력(input)은 기존 id 유지 -->
    <div class="row" style="gap:8px;">
      <div style="flex:0 0 170px;">
        <select id="qeStatusPreset">
          <option value="">(preset)</option>
          <option value="NS">NS</option>
          <option value="1H">1H</option>
          <option value="HT">HT</option>
          <option value="2H">2H</option>
          <option value="ET">ET</option>
          <option value="BT">BT</option>
          <option value="P">P</option>
          <option value="FT">FT</option>
          <option value="AET">AET</option>
          <option value="PEN">PEN</option>
          <option value="SUSP">SUSP</option>
          <option value="INT">INT</option>
          <option value="PST">PST</option>
          <option value="CANC">CANC</option>
          <option value="ABD">ABD</option>
          <option value="AWD">AWD</option>
          <option value="WO">WO</option>
          <option value="LIVE">LIVE</option>
        </select>
      </div>
      <div style="flex:1 1 auto;">
        <input id="qeStatus" placeholder="(keep) 또는 직접 입력" autocomplete="off" inputmode="latin"/>
      </div>
    </div>
  </div>
</div>




        <div class="row">
          <div style="flex:1 1 220px;">
            <label class="muted" data-help="qeHomeFt">Home FT</label>
            <input id="qeHomeFt" type="number" placeholder="home.ft"/>
          </div>
          
          <div style="flex:1 1 220px;">
            <label class="muted" data-help="qeAwayFt">Away FT</label>
            <input id="qeAwayFt" type="number" placeholder="away.ft"/>
          </div>
        </div>

        <div class="row">
          <div style="flex:1 1 220px;">
            <label class="muted" data-help="qeHomeHt">Home HT</label>
            <input id="qeHomeHt" type="number" placeholder="home.ht"/>
          </div>
          <div style="flex:1 1 220px;">
            <label class="muted" data-help="qeAwayHt">Away HT</label>
            <input id="qeAwayHt" type="number" placeholder="away.ht"/>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="primary" onclick="applyQuickEditToPatch()" data-help="btnApplyQuickEdit">Quick Edit → Patch JSON 반영</button>
          <button onclick="upsertOverride()" data-help="btnUpsertOverride">저장(Upsert)</button>
        </div>


        <!-- Event Editor -->
        <div style="height:12px;"></div>
        <div class="subcard">
          <h3 data-help="evtEditor">Event Editor (Goals / Cards / Subs)</h3>

          <div class="row" style="align-items:flex-end;">
            <div style="flex:1 1 320px;">
              <label class="muted mini" data-help="evtPath">이벤트 배열 경로(자동 탐지)</label>
              <select id="evtPath"></select>
              <div class="muted mini" id="evtHint" style="margin-top:6px;"></div>
            </div>
            <div style="flex:0 0 360px;">
              <div class="btnGrid">
                <button class="btnsm" onclick="evtReloadFromBundle()" data-help="btnEvtReload">bundle에서 불러오기</button>
                <button class="btnsm" onclick="evtApplyToPatch(false)" data-help="btnEvtApply">Patch에 반영</button>
                <button class="btnsm danger" onclick="evtClearAll()" data-help="btnEvtClear">전체 삭제</button>
              </div>
            </div>


          </div>

          <div style="height:10px;"></div>

          <!-- Add row -->
          <div class="grid2">
            <div>
              <label class="muted mini">Minute</label>
              <input id="evtMin" type="number" placeholder="예: 57" />
            </div>
            <div>
              <label class="muted mini">Extra(+)</label>
              <input id="evtExtra" type="number" placeholder="예: 2 (없으면 비움)" />
            </div>

            <div>
              <label class="muted mini">Team</label>
              <select id="evtTeam">
                <option value="">(none)</option>
                <option value="home">home</option>
                <option value="away">away</option>
              </select>
            </div>
            <div>
              <label class="muted mini">Type</label>
              <select id="evtType">
                <option value="GOAL">GOAL</option>
                <option value="PENALTY">PENALTY</option>
                <option value="OWN_GOAL">OWN_GOAL</option>
                <option value="RED">RED</option>
                <option value="YELLOW">YELLOW</option>
                <option value="SUB">SUB</option>
                <option value="OTHER">OTHER</option>
              </select>

            </div>

            <div>
              <label class="muted mini">Player / Main</label>
              <input id="evtPlayer" placeholder="예: Messi / Player name" />
            </div>
            <div>
              <label class="muted mini">Assist / SubOut</label>
              <input id="evtAssist" placeholder="예: Assist / Sub out" />
            </div>

            <div style="grid-column: 1 / -1;">
              <label class="muted mini">Detail</label>
              <input id="evtDetail" placeholder="예: Penalty / 2nd yellow / Injury / Note" />
            </div>

            <div style="grid-column: 1 / -1; display:flex; gap:8px;">
              <button class="btnsm primary" onclick="evtAdd()" data-help="btnEvtAdd">+ 이벤트 추가</button>
              <button class="btnsm" onclick="evtSort()" data-help="btnEvtSort">정렬(시간순)</button>
            </div>

          </div>

          <div style="height:10px;"></div>

          <div class="muted mini">이벤트 목록 (행 수정/삭제 가능) · 수정하면 Patch JSON에 자동 반영됩니다</div>
          <div style="height:6px;"></div>

          <table class="evtTable" style="width:100%; border-collapse:collapse;">
            <thead>
              <tr>
                <th style="width:80px;">min</th>
                <th style="width:80px;">extra(+)</th>
                <th style="width:70px;">team</th>
                <th style="width:90px;">type</th>
                <th>main</th>
                <th>assist/sub</th>
                <th>detail</th>
                <th style="width:80px;">del</th>

              </tr>
            </thead>
            <tbody id="evtBody"></tbody>
          </table>
        </div>


        <div style="height:10px;"></div>
        <label class="muted" data-help="patchJson">Patch JSON (부분만)</label>
        <textarea id="patch" placeholder='예: { "venue_name": "Edited", "home": { "ft": 2 } }'></textarea>

        <div id="ovResult" class="muted" style="margin-top:10px;"></div>
      </div>

      
    </div>
  </div>

<script>
  const adminPath = (location.pathname || "").replace(/^\/+/, "").split("/")[0] || "";
  document.getElementById("adminPathText").textContent = "/" + adminPath;

  const tokenKey = "SSX_ADMIN_TOKEN";
  let selectedFixture = null;

  let bundleRaw = null;
  let bundleMerged = null;

  // ✅ override-only 모드(날짜 무시하고 override 적용된 fixture만 전체 조회)
  let overrideOnlyMode = false;

  // 현재(노출) fixtures
  let currentFixtures = [];

  // 원본(raw) fixtures 캐시: 같은 필터(date/tz/league_ids) 기준으로 한 번만 가져오기
  let rawCacheKey = "";
  let rawFixturesMap = null;


  function setStatusLine(msg) {
    document.getElementById("statusLine").textContent = msg || "";
  }

  function logoutToken() {
    localStorage.removeItem(tokenKey);
    alert("토큰을 삭제했습니다. 다음 admin API 호출 시 다시 입력합니다.");
  }

  function adminHeaders() {
    const t = localStorage.getItem(tokenKey) || "";
    return {
      "Content-Type": "application/json",
      "X-Admin-Token": t,
    };
  }

  function ensureToken() {
    let t = localStorage.getItem(tokenKey);
    if (!t) {
      t = prompt("관리자 토큰(ADMIN_TOKEN)을 입력하세요");
      if (t) localStorage.setItem(tokenKey, t);
    }
    return t;
  }

  function adminUrl(path) {
    return "/" + adminPath + path;
  }

  async function api(path, opt={}, _retried=false) {
  const t = ensureToken();
  if (!t) {
    // 사용자가 토큰 입력을 취소한 경우: 호출 중단
    return { status: 0, data: { ok: false, error: "no_admin_token" } };
  }

  const res = await fetch(path, {
    ...opt,
    headers: { ...(opt.headers||{}), ...adminHeaders() },
  });

  // ✅ 토큰이 틀렸거나 만료(401/403)면: 토큰 삭제 → 재입력 → 1회 재시도
  if ((res.status === 401 || res.status === 403) && !_retried) {
    localStorage.removeItem(tokenKey);
    const t2 = ensureToken();
    if (!t2) {
      return { status: res.status, data: { ok: false, error: "no_admin_token_retry" } };
    }
    return api(path, opt, true);
  }

  const txt = await res.text();
  let data = null;
  try { data = JSON.parse(txt); } catch (e) { data = { raw: txt }; }
  return { status: res.status, data };
}



  async function publicApi(path) {
    const res = await fetch(path);
    const txt = await res.text();
    let data = null;
    try { data = JSON.parse(txt); } catch (e) { data = { raw: txt }; }
    return { status: res.status, data };
  }

  function setOv(msg, ok=true) {
  const el = document.getElementById("ovResult");
  const safe = escapeHtml(msg);
  el.innerHTML = ok ? `<span class="ok">${safe}</span>` : `<span class="bad">${safe}</span>`;
}


  function safeNum(v) {
    if (v === "" || v === null || v === undefined) return null;
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }

  function normalizeLeagueIdsInput(v) {
    // "39, 140,78,,  " -> "39,140,78"
    const s = String(v || "").trim();
    if (!s) return "";
    return s
      .split(",")
      .map(x => x.trim())
      .filter(Boolean)
      .join(",");
  }

  function parseLeagueIdsSet(v) {
    const norm = normalizeLeagueIdsInput(v);
    if (!norm) return null;
    const set = new Set();
    for (const p of norm.split(",")) {
      const n = Number(String(p).trim());
      if (Number.isFinite(n)) set.add(n);
    }
    return set.size ? set : null;
  }


  function fxUpdateLeaguePills() {
    const box = document.getElementById("fxLeaguePills");
    const input = document.getElementById("fxLeagueIds");
    if (!box || !input) return;

    const set = parseLeagueIdsSet(input.value || "");
    box.innerHTML = "";

    if (!set || set.size === 0) {
      const d = document.createElement("span");
      d.className = "pill";
      d.textContent = "(전체 리그)";
      box.appendChild(d);
      return;
    }

    const ids = Array.from(set).sort((a,b)=>a-b);

    // 너무 길어지면 앞부분만 보여주고 count로 표시
    const maxShow = 10;
    const shown = ids.slice(0, maxShow);
    for (const id of shown) {
      const p = document.createElement("span");
      p.className = "pill";
      p.textContent = String(id);
      box.appendChild(p);
    }

    if (ids.length > maxShow) {
      const more = document.createElement("span");
      more.className = "pill";
      more.textContent = `+${ids.length - maxShow}`;
      box.appendChild(more);
    }
  }


  // ─────────────────────────────────────
  // League dropdown (from loaded fixtures)
  // ─────────────────────────────────────

  function fxRefreshLeaguePick() {
    const sel = document.getElementById("fxLeaguePick");
    const input = document.getElementById("fxLeagueIds");
    if (!sel || !input) return;

    const prevSel = String(sel.value || "").trim();

    // 현재 로드된 fixtures에서 league 목록 수집
    const m = new Map(); // league_id -> {id,name,country}
    for (const f of (currentFixtures || [])) {
      const id = Number(f.league_id);
      if (!Number.isFinite(id)) continue;
      if (!m.has(id)) {
        m.set(id, {
          id,
          name: (f.league_name || `League ${id}`),
          country: (f.league_country || ""),
        });
      }
    }

    const arr = Array.from(m.values()).sort((a, b) => {
      const an = String(a.name || "");
      const bn = String(b.name || "");
      const c = an.localeCompare(bn);
      return c !== 0 ? c : (a.id - b.id);
    });

    sel.innerHTML = "";

    const optAll = document.createElement("option");
    optAll.value = "";
    optAll.textContent = "(전체 리그)";
    sel.appendChild(optAll);

    if (!arr.length) {
      const optNone = document.createElement("option");
      optNone.value = "";
      optNone.textContent = "(이 기간에 리그 없음)";
      sel.appendChild(optNone);
      sel.value = "";
      input.value = "";
      fxUpdateLeaguePills();
      return;
    }

    for (const x of arr) {
      const opt = document.createElement("option");
      opt.value = String(x.id);
      opt.textContent = `${x.name}${x.country ? " · " + x.country : ""} · ${x.id}`;
      sel.appendChild(opt);
    }

    // 선택 복원
    if (prevSel && arr.some(x => String(x.id) === prevSel)) sel.value = prevSel;
    else sel.value = "";

    // 단일 필터면 드롭다운도 맞춤
    const set = parseLeagueIdsSet(input.value || "");
    if (set && set.size === 1) {
      const only = Array.from(set)[0];
      if (arr.some(x => x.id === only)) sel.value = String(only);
    }

    fxUpdateLeaguePills();
  }


  function fxAddLeagueFromPick() {
    const sel = document.getElementById("fxLeaguePick");
    const input = document.getElementById("fxLeagueIds");
    if (!sel || !input) return;

    const v = String(sel.value || "").trim();
    if (!v) return;

    const set = parseLeagueIdsSet(input.value || "") || new Set();
    const n = Number(v);
    if (!Number.isFinite(n)) return;

    set.add(n);
    input.value = Array.from(set).sort((a,b)=>a-b).join(",");

    fxUpdateLeaguePills();
    renderFixtures();
  }


  function fxRemoveLeagueFromPick() {
    const sel = document.getElementById("fxLeaguePick");
    const input = document.getElementById("fxLeagueIds");
    if (!sel || !input) return;

    const v = String(sel.value || "").trim();
    if (!v) return;

    const set = parseLeagueIdsSet(input.value || "");
    if (!set) return;

    const n = Number(v);
    if (!Number.isFinite(n)) return;

    set.delete(n);
    input.value = Array.from(set).sort((a,b)=>a-b).join(",");

    fxUpdateLeaguePills();
    renderFixtures();
  }


  function fxClearLeagueFilter() {
    const sel = document.getElementById("fxLeaguePick");
    const input = document.getElementById("fxLeagueIds");
    if (input) input.value = "";
    if (sel) sel.value = "";
    fxUpdateLeaguePills();
    renderFixtures();
  }



  // ✅ innerHTML에 들어갈 값 최소 이스케이프(XSS 방어)
  function escapeHtml(s) {
    return String(s ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

function escapeAttr(s) {
  // 속성값(src 등)에 안전하게 넣기 위한 최소 처리
  // ✅ 개행/제어문자 때문에 attribute 깨지는 케이스 방지
  return escapeHtml(String(s ?? "").replace(/[\r\n\t]/g, " "));
}

// ✅ img src 등 URL은 http/https만 허용(깨진 값/위험 스킴 방지)
function safeUrl(u) {
  const s = String(u ?? "").trim();
  if (!s) return "";
  try {
    const url = new URL(s, location.origin);
    if (url.protocol === "http:" || url.protocol === "https:") return url.href;
    return "";
  } catch (e) {
    return "";
  }
}

/* ─────────────────────────────────────
   Help system: data-help="key" 붙은 타이틀에 ! 아이콘 자동 추가
   ───────────────────────────────────── */
const HELP = {
  // ===== Fixtures Browser =====
  fxBrowser: {
    title: "Fixtures Browser",
    body:
`왼쪽은 경기 목록(merged 기준) 탐색기입니다.
- 불러오기: 기간(from~to)로 fixtures_merged를 조회합니다.
- OVR만 보기: 같은 기간 중 override가 있는 경기만 모아봅니다.
목록 클릭 시 오른쪽 편집기와 하단 비교 탭이 함께 갱신됩니다.`
  },
  fxDateFrom: {
    title: "Date (From)",
    body:
`조회 시작 날짜입니다.
from~to 범위를 최대 31일까지 지원합니다.
from만 있으면 하루 조회, to까지 있으면 기간 조회로 동작합니다.`
  },
  fxDateTo: {
    title: "Date (To)",
    body:
`조회 종료 날짜입니다.
비워두면 from과 동일하게 처리됩니다.
from보다 이전 날짜를 넣으면 자동으로 swap(뒤집기)해서 처리합니다.`
  },
  fxTz: {
    title: "Timezone",
    body:
`표시/비교 기준 타임존입니다.
- 리스트 시간 표시(fmtInTz)
- raw 비교 날짜 산출(ymdInTz)
- 서버 조회 파라미터 timezone
에 사용됩니다.`
  },
  fxLeagueFilter: {
    title: "League Filter",
    body:
`로드된 fixtures에서 리그 목록을 만들고 UI 필터링합니다.
- + : 선택 리그를 필터에 추가
- − : 선택 리그를 필터에서 제거
- ALL : 전체 리그(필터 초기화)
아래 pill은 현재 league_ids 상태입니다.
※ 서버가 league_ids를 무시해도 UI에서 한 번 더 강제 필터합니다.`
  },
  fxSearch: {
    title: "Search (team/league)",
    body:
`서버 재호출 없이 목록을 즉시 필터링합니다.
팀/리그/라운드/국가/fixture_id를 합쳐서 부분검색합니다.`
  },
  fxActions: {
    title: "Actions",
    body:
`불러오기:
- from~to 각 날짜를 순회하며 fixtures_merged를 합칩니다(중복 fixture_id는 dedupe).
OVR만 보기:
- 같은 방식으로 조회하되 _has_override=true 인 경기만 모읍니다.
버튼 테두리(primary)로 모드가 표시됩니다.`
  },

  // ===== Override Editor =====
  ovEditor: {
    title: "Override Editor",
    body:
`오른쪽은 선택한 fixture의 override patch를 편집/저장합니다.
- 조회: /api/overrides/{id} 로 patch를 읽어 textarea에 반영
- 저장(Upsert): patch가 비어있으면 저장을 막고, 저장 후 목록을 재로딩합니다
- 삭제(원복): override 레코드를 삭제하고 원본으로 되돌립니다.`
  },
  fixtureId: {
    title: "Fixture ID",
    body:
`override를 적용할 대상 경기의 fixture_id 입니다.
왼쪽 목록에서 경기를 클릭하면 자동으로 채워집니다.`
  },
  quickActions: {
    title: "Quick actions",
    body:
`조회: 현재 override patch 조회
삭제(원복): override 제거(원본 복구)
숨김(hidden=true): patch에 hidden:true 세팅(저장 전)
숨김해제(hidden=false): patch에 hidden:false 세팅(저장 전)`
  },
  qeVenue: {
    title: "Venue",
    body:
`경기장 이름(venue_name) 오버라이드입니다.
비워두면 변경하지 않도록 patch에는 '변경된 항목만' 들어가게 설계되어 있습니다.`
  },
  qeRound: {
    title: "League Round",
    body:
`리그 라운드 표기(league_round) 오버라이드입니다.
앱/리스트에 보이는 라운드 텍스트를 강제로 바꿀 때 사용합니다.`
  },
  qeStatusLong: {
    title: "Status Long",
    body:
`status_long(문장형 상태) 오버라이드입니다.
예: "Second Half", "Match Finished" 같은 표시용 텍스트.`
  },
  qeElapsed: {
    title: "Elapsed",
    body:
`경과 분(elapsed) 오버라이드입니다.
리스트/상세에서 진행 분 표시를 보정할 때 사용합니다.`
  },
  qeStatusGroup: {
    title: "Status Group",
    body:
`상태 그룹(status_group)입니다.
UPCOMING / INPLAY / FINISHED / PST / SUSP / CANC / TBD 등.
프리셋 드롭다운 선택 시 input에 자동 반영되고,
저장 시 대문자로 정규화해서 불필요한 diff를 줄입니다.`
  },
  qeStatus: {
    title: "Status",
    body:
`짧은 상태 코드(status)입니다.
NS/1H/HT/2H/FT/ET/PEN/PST/CANC 등.
프리셋 → input 자동 반영, 저장 시 대문자 정규화합니다.`
  },
  qeHomeFt: {
    title: "Home FT",
    body:
`홈팀 풀타임 득점(home.ft) 오버라이드입니다.
원본과 다를 때만 patch에 들어가도록 설계되어 있습니다.`
  },
  qeAwayFt: {
    title: "Away FT",
    body:
`원정팀 풀타임 득점(away.ft) 오버라이드입니다.`
  },
  qeHomeHt: {
    title: "Home HT",
    body:
`홈팀 하프타임 득점(home.ht) 오버라이드입니다.`
  },
  qeAwayHt: {
    title: "Away HT",
    body:
`원정팀 하프타임 득점(away.ht) 오버라이드입니다.`
  },
  patchJson: {
    title: "Patch JSON (부분만)",
    body:
`override에 저장될 JSON patch 입니다.
- object만 허용됩니다(배열 root는 저장 불가).
- Quick Edit / Event Editor가 여기에 반영됩니다.
- 저장 전에는 적용되지 않습니다(Upsert 필요).`
  },

  // ===== Event Editor =====
  evtEditor: {
    title: "Event Editor (Goals / Cards / Subs)",
    body:
`득점/카드/교체 이벤트 배열을 편집해 patch로 덮어씁니다.
bundle(raw/merged)에서 이벤트 배열 경로를 자동 탐지하고,
선택된 경로의 배열을 UI로 로드해서 수정/추가/삭제합니다.`
  },
  evtPath: {
    title: "이벤트 배열 경로(자동 탐지)",
    body:
`bundle 구조를 훑어서 '이벤트 배열'로 보이는 배열 후보를 점수화해 보여줍니다.
가장 점수 높은 후보가 자동 선택되며,
경로를 바꾸면 해당 경로의 배열을 다시 로드합니다.`
  },
  evtReload: {
    title: "bundle에서 불러오기",
    body:
`현재 선택된 fixture의 bundle(raw/merged)에서 이벤트 배열을 다시 읽어옵니다.
(override 저장 전이라면 merged/raw 상태에 따라 내용이 달라질 수 있습니다.)`
  },
  evtApply: {
    title: "Patch에 반영",
    body:
`현재 UI 이벤트 목록을 Patch JSON의 선택 경로에 '배열 통째로' 세팅합니다.
즉시 저장되는 건 아니며, Upsert를 눌러야 적용됩니다.`
  },
  evtClear: {
    title: "전체 삭제",
    body:
`선택된 이벤트 배열을 빈 배열로 override합니다.
주의: 저장(Upsert)하면 앱에서도 이벤트가 모두 사라집니다.`
  },
  evtMinute: {
    title: "Minute / Extra(+)",
    body:
`Minute: 기본 시간(예: 57)
Extra(+): 추가시간(예: 2)
정렬(시간순)은 minute → extra 순으로 오름차순 정렬합니다.`
  },
  evtTeam: {
    title: "Team",
    body:
`home/away 어느 팀 이벤트인지 표시합니다.
타임라인 스키마가 있는 경우 side_home 같은 키도 같이 동기화합니다.`
  },
  evtType: {
    title: "Type",
    body:
`GOAL/RED/YELLOW/SUB 등 이벤트 종류입니다.
PENALTY/OWN_GOAL은 UI 편의용 타입이고,
저장 시 raw에는 GOAL + detail(“Penalty/Own Goal”)로 안전하게 기록합니다.`
  },

  // ===== Tabs (now/raw/patch/diff/bundle) =====
  tabNow: {
    title: "현재(노출)",
    body:
`fixtures_merged 기준 “현재 앱에 노출되는 형태”를 보여줍니다.
override / hidden 등이 반영된 최종 결과(JSON)입니다.`
  },
  tabRaw: {
    title: "원본(raw)",
    body:
`override 미적용 “원본 fixture”입니다.
같은 경기라도 타임존/날짜 기준에 따라 raw 조회가 달라질 수 있어
선택 경기의 날짜를 tz 기준으로 잡아 로드합니다.`
  },
  tabPatch: {
    title: "override patch",
    body:
`현재 override에 저장된 “patch(부분 JSON)”입니다.
오른쪽 Patch textarea 내용이 그대로 반영되어 표시됩니다.`
  },
  tabDiff: {
    title: "diff",
    body:
`원본(raw) → 현재(노출) 변화 요약입니다.
path 단위로 raw 값과 now 값을 비교해 줄 단위로 보여줍니다.`
  },
  tabBundleRaw: {
    title: "bundle(raw)",
    body:
`match_detail_bundle를 override 미적용(apply_override=0)으로 호출한 결과입니다.
Event Editor 자동 탐지/로드의 기준 데이터로도 사용됩니다.`
  },
  tabBundleMerged: {
    title: "bundle(merged)",
    body:
`match_detail_bundle를 override 적용(apply_override=1)으로 호출한 결과입니다.
Event Editor는 기본적으로 merged 우선으로 로드합니다.`
  },
  tabBundleDiff: {
    title: "bundle diff",
    body:
`bundle(raw) → bundle(merged) 차이 요약입니다.
bundle 안에서 override가 실제로 무엇을 바꿨는지 빠르게 확인합니다.`
  },

  // ===== Buttons (right-side ! on buttons) =====
  btnLoadFixtures: {
    title: "불러오기",
    body:
`from~to 기간의 fixtures_merged를 날짜별로 조회해 합칩니다.
- fixture_id 기준으로 중복 제거(dedupe)
- timezone / league_ids 파라미터 포함
로드 후 리그 드롭다운 목록도 새로 구성됩니다.`
  },

  btnOverridesOnly: {
    title: "OVR만 보기",
    body:
`현재 기간(from~to)에서 override가 있는 경기만 모아봅니다.
- 다시 누르면 일반 불러오기 모드로 복귀(토글)
- 버튼 테두리(primary)로 현재 모드가 표시됩니다.`
  },
  btnFxLeagueAdd: {
    title: "+ (리그 추가)",
    body:
`현재 선택된 리그를 league_ids 필터에 추가합니다.
추가 즉시 UI 리스트가 필터링되어 보입니다(서버 재호출 없음).`
  },
  btnFxLeagueRemove: {
    title: "− (리그 제거)",
    body:
`현재 선택된 리그를 league_ids 필터에서 제거합니다.
제거 즉시 UI 리스트가 다시 렌더링됩니다.`
  },
  btnFxLeagueAll: {
    title: "ALL (필터 초기화)",
    body:
`league_ids 필터를 비워서 전체 리그를 보이게 합니다.
(서버가 league_ids를 무시해도 UI에서 강제 필터가 해제됩니다.)`
  },

  btnGetOverride: {
    title: "조회",
    body:
`/api/overrides/{fixture_id} 를 호출해 현재 override patch를 불러옵니다.
- patch가 있으면 textarea에 반영
- 이후 비교뷰(raw/diff)와 bundle(raw/merged)도 갱신합니다.`
  },
  btnDeleteOverride: {
    title: "삭제(원복)",
    body:
`override 레코드를 삭제해 원본으로 되돌립니다.
성공하면 patch textarea를 비우고 목록을 재로드합니다.`
  },
  btnHideFixture: {
    title: "숨김(hidden=true)",
    body:
`Patch JSON에 hidden:true 를 세팅합니다.
즉시 적용은 아니고, 저장(Upsert)해야 실제 반영됩니다.`
  },
  btnUnhideFixture: {
    title: "숨김해제(hidden=false)",
    body:
`Patch JSON에 hidden:false 를 세팅합니다.
저장(Upsert) 전까지는 실제 노출 상태가 바뀌지 않습니다.`
  },

  btnApplyQuickEdit: {
    title: "Quick Edit → Patch 반영",
    body:
`Quick Edit 입력값을 기준으로 “변경된 항목만” Patch JSON에 합칩니다.
- status/status_group은 대문자 정규화
- 점수(ft/ht)는 바뀐 값만 home/away에 부분 패치로 들어갑니다.`
  },
  btnUpsertOverride: {
    title: "저장(Upsert)",
    body:
`현재 Patch JSON을 PUT으로 저장해 override를 즉시 적용합니다.
- Patch가 빈 객체면 저장을 막습니다(OVR만 생기는 문제 방지)
- 저장 성공 시 목록을 다시 불러와 merged 결과를 갱신합니다.`
  },

  btnEvtReload: {
    title: "bundle에서 불러오기",
    body:
`bundle(raw/merged)를 기준으로 이벤트 배열 경로를 자동 탐지하고,
선택된 경로의 이벤트 배열을 UI 편집 표로 로드합니다.`
  },
  btnEvtApply: {
    title: "Patch에 반영",
    body:
`현재 UI의 이벤트 목록을 Patch JSON의 선택 경로에
“배열 통째로” 덮어씌웁니다.
저장은 아니므로 Upsert를 눌러야 적용됩니다.`
  },
  btnEvtClear: {
    title: "전체 삭제",
    body:
`선택된 이벤트 배열을 빈 배열로 override합니다.
저장(Upsert)하면 앱에서도 이벤트가 전부 사라집니다.`
  },
  btnEvtAdd: {
    title: "+ 이벤트 추가",
    body:
`입력한 minute/extra/team/type/main/assist/detail로 이벤트를 추가합니다.
- PENALTY/OWN_GOAL은 저장 시 GOAL + detail로 안전하게 기록합니다.`
  },
  btnEvtSort: {
    title: "정렬(시간순)",
    body:
`minute → extra 순으로 오름차순 정렬합니다.
정렬 후 Patch JSON에도 즉시 반영됩니다.`
  },

};

let _helpPopEl = null;

function closeHelpPop(){
  if (_helpPopEl && _helpPopEl.parentNode) _helpPopEl.parentNode.removeChild(_helpPopEl);
  _helpPopEl = null;
}

function openHelpPop(anchorEl, key){
  const h = HELP[key];
  if (!h) return;

  closeHelpPop();

  const pop = document.createElement("div");
  pop.className = "helpPop";
  pop.innerHTML = `
    <div class="hTitle">
      <span>${escapeHtml(h.title || "도움말")}</span>
      <button class="hClose" type="button">닫기</button>
    </div>
    <div class="hBody">${escapeHtml(h.body || "")}</div>
    <div class="hHint">Tip: 같은 항목은 ! 아이콘으로 언제든 다시 확인</div>
  `;

  document.body.appendChild(pop);
  _helpPopEl = pop;

  const rect = anchorEl.getBoundingClientRect();
  const pad = 10;

  // 기본: 아이콘 오른쪽 아래
  let left = rect.left + window.scrollX + 22;
  let top  = rect.top  + window.scrollY + 22;

  // 화면 밖이면 보정
  const pr = pop.getBoundingClientRect();
  const maxLeft = window.scrollX + window.innerWidth - pr.width - pad;
  const maxTop  = window.scrollY + window.innerHeight - pr.height - pad;

  left = Math.max(window.scrollX + pad, Math.min(left, maxLeft));
  top  = Math.max(window.scrollY + pad, Math.min(top, maxTop));

  pop.style.left = left + "px";
  pop.style.top  = top + "px";

  pop.querySelector(".hClose").onclick = closeHelpPop;

  // 바깥 클릭 닫기
  setTimeout(() => {
    window.addEventListener("mousedown", onOutside, { once:true });
  }, 0);

  function onOutside(ev){
    if (!pop.contains(ev.target)) closeHelpPop();
  }
}

function attachHelpIcons(){
  // data-help 가진 요소에 ! 아이콘 자동 추가
  // - 일반 요소(h2/label 등): 요소 내부 맨 오른쪽에 append
  // - 버튼(button): 기본은 버튼 "바로 오른쪽" 형제 삽입
  // - ✅ tabbtn(탭 버튼)은 레이아웃 깨짐 방지로 버튼 "내부"에 append
  const nodes = document.querySelectorAll("[data-help]");

  nodes.forEach(el => {
    const key = el.getAttribute("data-help");
    if (!key || !HELP[key]) return;

    const isButton = (el.tagName === "BUTTON");
    const isTabBtn = isButton && el.classList && el.classList.contains("tabbtn");
    const placeInside = (!isButton) || isTabBtn;

    // ✅ 중복 방지
    if (!placeInside) {
      const next = el.nextElementSibling;
      if (next && next.classList && next.classList.contains("helpIcon")) return;
    } else {
      if (el.querySelector && el.querySelector(".helpIcon")) return;
    }

    const icon = document.createElement("span");
    icon.className = "helpIcon";
    icon.textContent = "!";
    icon.title = "도움말";
    icon.onclick = (e) => {
      e.stopPropagation();
      openHelpPop(icon, key);
    };

    if (placeInside) {
      el.appendChild(icon);
    } else {
      el.insertAdjacentElement("afterend", icon);
    }
  });
}



// DOM 준비 후 1회 부착
document.addEventListener("DOMContentLoaded", () => {
  attachHelpIcons();
});

  function deepMerge(base, patch) {

    if (base && typeof base === "object" && !Array.isArray(base) &&
        patch && typeof patch === "object" && !Array.isArray(patch)) {
      const out = { ...base };
      for (const k of Object.keys(patch)) {
        out[k] = deepMerge(out[k], patch[k]);
      }
      return out;
    }
    return patch;
  }

  function isoDateLocal() {
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2, "0");
    const dd = String(d.getDate()).padStart(2, "0");
    return `${yyyy}-${mm}-${dd}`;
  }

  function parseYmdToUtcDate(ymd) {
    // "YYYY-MM-DD" -> Date(UTC 기준)
    // ✅ 로컬 타임존 영향 제거용: 항상 Z로 고정
    return new Date(String(ymd).trim() + "T00:00:00Z");
  }

  function fmtUtcDateToYmd(d) {
    // Date -> "YYYY-MM-DD"
    return d.toISOString().slice(0, 10);
  }

  function enumerateYmdRange(fromYmd, toYmd, maxDays = 31) {
    const a = String(fromYmd || "").trim();
    const b = String(toYmd || "").trim();
    if (!a) return { ok:false, days:[], error:"from_date_required" };

    const fromD = parseYmdToUtcDate(a);
    const toD = parseYmdToUtcDate(b || a);

    if (!Number.isFinite(fromD.getTime()) || !Number.isFinite(toD.getTime())) {
      return { ok:false, days:[], error:"invalid_date" };
    }

    // ✅ 뒤집혔으면 swap
    let start = fromD;
    let end = toD;
    if (end.getTime() < start.getTime()) {
      const tmp = start; start = end; end = tmp;
    }

    const days = [];
    let cur = start;
    for (let i=0; i<maxDays; i++) {
      days.push(fmtUtcDateToYmd(cur));
      if (fmtUtcDateToYmd(cur) === fmtUtcDateToYmd(end)) break;
      cur = new Date(cur.getTime() + 86400000); // +1 day
    }

    // ✅ maxDays 초과 감지(끝까지 못 감)
    if (days[days.length-1] !== fmtUtcDateToYmd(end)) {
      return { ok:false, days:[], error:`range_too_large(max=${maxDays})` };
    }

    return { ok:true, days, error:null };
  }


  function fmtInTz(dateUtcStr, tz) {
    try {
      const d = new Date(dateUtcStr);
      return d.toLocaleString("sv-SE", { timeZone: tz, hour12: false }).replace(" ", " ");
    } catch (e) {
      return dateUtcStr || "";
    }
  }

  function ymdInTz(dateUtcStr, tz) {
    // dateUtcStr(UTC) -> tz 기준 YYYY-MM-DD
    try {
      const d = new Date(dateUtcStr);
      const parts = new Intl.DateTimeFormat("sv-SE", {
        timeZone: tz,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
      }).formatToParts(d);
      const y = parts.find(p => p.type === "year")?.value || "1970";
      const m = parts.find(p => p.type === "month")?.value || "01";
      const da = parts.find(p => p.type === "day")?.value || "01";
      return `${y}-${m}-${da}`;
    } catch (e) {
      return "";
    }
  }

  function setOverrideMode(on) {
    overrideOnlyMode = !!on;

    const btn = document.getElementById("btnOverridesOnly");
    if (btn) {
      // ✅ 켜짐 표시(테두리 강조)
      btn.classList.toggle("primary", overrideOnlyMode);
      btn.textContent = overrideOnlyMode ? "OVR 보기중" : "OVR만 보기";
      btn.title = overrideOnlyMode ? "클릭하면 일반 날짜 조회로 돌아갑니다" : "override 적용된 fixture만 전체 조회";
    }

    // raw 캐시 무효화(모드가 바뀌면 key 의미가 달라짐)
    rawFixturesMap = null;
    rawCacheKey = "";
  }


  function statusOrderKey(sg) {
  const v = (sg || "").toUpperCase();
  if (v === "INPLAY" || v.includes("LIVE")) return 0;
  if (v === "UPCOMING" || v === "NS") return 1;
  if (v === "FINISHED" || v.includes("FT")) return 9;
  // 나머지(PST/SUSP/CANC/TBD 등)는 중간
  return 5;
}



  function showTab(name) {
    const names = ["now","raw","patch","diff","bundle_raw","bundle_merged","bundle_diff"];
    for (const n of names) {
      const pane = document.getElementById("tab_" + n);
      const btn = document.getElementById("tab_" + n + "_btn");
      if (pane) pane.classList.toggle("active", n === name);
      if (btn) btn.classList.toggle("active", n === name);
    }
  }


  function renderFixtures() {
  const list = document.getElementById("fxList");
  if (!list) return;
  list.innerHTML = "";

  const q = (document.getElementById("fxSearch")?.value || "").trim().toLowerCase();
  const leagueSet = parseLeagueIdsSet(document.getElementById("fxLeagueIds")?.value || "");

  const filtered = (currentFixtures || []).filter(f => {
    if (leagueSet && !leagueSet.has(Number(f.league_id))) return false;

    if (!q) return true;
    const s = [
      f.league_name, f.league_country, f.league_round,
      f.home?.name, f.away?.name,
      String(f.fixture_id || "")
    ].join(" ").toLowerCase();
    return s.includes(q);
  });

  filtered.sort((a, b) => {
    const ka = statusOrderKey(a.status_group);
    const kb = statusOrderKey(b.status_group);
    if (ka !== kb) return ka - kb;
    return String(a.date_utc || "").localeCompare(String(b.date_utc || ""));
  });

  const tz = document.getElementById("fxTz")?.value || "UTC";

  for (const f of filtered) {
    const div = document.createElement("div");

    const isHidden = (f.hidden === true);
    div.className =
      "item" +
      ((selectedFixture && selectedFixture.fixture_id === f.fixture_id) ? " sel" : "") +
      (isHidden ? " hidden" : "");

    div.onclick = () => selectFixture(f.fixture_id);

    const when = fmtInTz(f.date_utc, tz);
    const score = `${f.home?.ft ?? "-"} : ${f.away?.ft ?? "-"}`;
    const ht = `${f.home?.ht ?? "-"} : ${f.away?.ht ?? "-"}`;

    const isOvr = (f._has_override === true);
    const sg = (f.status_group || "").toUpperCase();

    const badges = [
      `<span class="badge mono">${escapeHtml(sg || "?")}</span>`,
      isOvr ? `<span class="badge mono ovr">OVR</span>` : ``,
      isHidden ? `<span class="badge mono hid">HIDDEN</span>` : ``,
    ].filter(Boolean).join(" ");

    const hLogo = safeUrl(f.home?.logo);
    const aLogo = safeUrl(f.away?.logo);

    const homeLogo = hLogo
      ? `<img src="${escapeAttr(hLogo)}" style="width:16px;height:16px;border-radius:4px;opacity:0.95;">`
      : "";
    const awayLogo = aLogo
      ? `<img src="${escapeAttr(aLogo)}" style="width:16px;height:16px;border-radius:4px;opacity:0.95;">`
      : "";

    const leagueLine =
      `${escapeHtml(f.league_name || "")}` +
      `${f.league_country ? ` · ${escapeHtml(f.league_country)}` : ""}` +
      `${f.league_round ? ` · ${escapeHtml(f.league_round)}` : ""}` +
      `${Number.isFinite(Number(f.league_id)) ? ` · L:${escapeHtml(f.league_id)}` : ""}`;

    div.innerHTML = `
      <div style="min-width:0;">
        <div class="small muted mono">${escapeHtml(when)}</div>

        <div class="k fxTeams">
          <span class="fxTeam">
            ${homeLogo}
            <span class="fxTeamName">${escapeHtml(f.home?.name || "HOME")}</span>
          </span>

          <span class="muted">vs</span>

          <span class="fxTeam">
            ${awayLogo}
            <span class="fxTeamName">${escapeHtml(f.away?.name || "AWAY")}</span>
          </span>
        </div>

        <div class="small muted fxLeagueLine" style="margin-top:2px;">
          ${leagueLine}
        </div>
      </div>

      <div class="fxRight">
        <div class="fxBadges">${badges}</div>
        <div class="mono fxScore">${escapeHtml(score)}</div>
        <div class="small muted mono">HT ${escapeHtml(ht)}</div>
      </div>
    `;

    list.appendChild(div);
  }

  const total = (currentFixtures || []).length;
  const shown = filtered.length;

  const normLeague = normalizeLeagueIdsInput(document.getElementById("fxLeagueIds")?.value || "");
  const leagueHint = normLeague ? ` · league_ids=${normLeague}` : "";

  const fxHint = document.getElementById("fxHint");
  if (fxHint) {
    fxHint.textContent =
      `rows: ${shown} / ${total}${leagueHint} · 검색은 즉시 반영됩니다 · 클릭하면 원본/현재/차이까지 비교됩니다`;
  }
}



  function fillQuickEditFromFixture(f) {
    document.getElementById("qeVenue").value = f.venue_name ?? "";
    document.getElementById("qeRound").value = f.league_round ?? "";
    document.getElementById("qeStatusLong").value = f.status_long ?? "";
    document.getElementById("qeElapsed").value = (f.elapsed ?? "") === null ? "" : (f.elapsed ?? "");
    document.getElementById("qeStatusGroup").value = f.status_group ?? "";
    document.getElementById("qeStatus").value = f.status ?? "";
    document.getElementById("qeStatusGroupPreset").value = (f.status_group ?? "").toUpperCase();
    document.getElementById("qeStatusPreset").value = (f.status ?? "").toUpperCase();


    document.getElementById("qeHomeFt").value = (f.home?.ft ?? "") === null ? "" : (f.home?.ft ?? "");
    document.getElementById("qeAwayFt").value = (f.away?.ft ?? "") === null ? "" : (f.away?.ft ?? "");
    document.getElementById("qeHomeHt").value = (f.home?.ht ?? "") === null ? "" : (f.home?.ht ?? "");
    document.getElementById("qeAwayHt").value = (f.away?.ht ?? "") === null ? "" : (f.away?.ht ?? "");
  }

  function renderSelectedSummary(f) {
    const box = document.getElementById("selSummary");
    if (!box) return;

    if (!f) {
      box.style.display = "none";
      return;
    }

    const tz = document.getElementById("fxTz").value || "UTC";
    const when = fmtInTz(f.date_utc, tz);

    const sg = (f.status_group || "").toUpperCase();
    const isOvr = (f._has_override === true);
    const isHidden = (f.hidden === true);

    const score = `${f.home?.ft ?? "-"} : ${f.away?.ft ?? "-"}`;
    const ht = `${f.home?.ht ?? "-"} : ${f.away?.ht ?? "-"}`;

    document.getElementById("selSummaryMeta").textContent =
      `${when} · ${f.league_name || ""}${f.league_round ? " · " + f.league_round : ""} · L:${f.league_id ?? "-"}`;

    const homeLogo = document.getElementById("selHomeLogo");
    const awayLogo = document.getElementById("selAwayLogo");

   if (homeLogo) {
  const u = safeUrl(f.home?.logo);
  if (u) { homeLogo.src = u; homeLogo.style.display = ""; }
  else { homeLogo.style.display = "none"; }
}
if (awayLogo) {
  const u = safeUrl(f.away?.logo);
  if (u) { awayLogo.src = u; awayLogo.style.display = ""; }
  else { awayLogo.style.display = "none"; }
}


    document.getElementById("selHomeName").textContent = f.home?.name || "HOME";
    document.getElementById("selAwayName").textContent = f.away?.name || "AWAY";
    document.getElementById("selScore").textContent = score;
    document.getElementById("selHt").textContent = `HT ${ht}`;

    const badges = [
      `<span class="badge mono">${escapeHtml(sg || "?")}</span>`,
      isOvr ? `<span class="badge mono ovr">OVR</span>` : ``,
      isHidden ? `<span class="badge mono hid">HIDDEN</span>` : ``,
    ].filter(Boolean).join(" ");


    document.getElementById("selBadges").innerHTML = badges;

    box.style.display = "";
  }



  function getFilterKey() {
    const tz = document.getElementById("fxTz").value || "UTC";
    const leagueIds = normalizeLeagueIdsInput(document.getElementById("fxLeagueIds").value || "");

    // ✅ Raw 비교는 "선택된 경기의 날짜(해당 tz 기준)"로 잡아야 기간 조회에서도 정확함
    const date =
      (selectedFixture && selectedFixture.date_utc)
        ? ymdInTz(selectedFixture.date_utc, tz)
        : (document.getElementById("fxDate").value || "");

    return `${date}__${tz}__${leagueIds}`;
  }





  function buildFixturesQuery(dateOverride) {
    const tz = document.getElementById("fxTz").value || "UTC";
    const leagueIds = normalizeLeagueIdsInput(document.getElementById("fxLeagueIds").value || "");

    const date = (dateOverride != null && String(dateOverride).trim() !== "")
      ? String(dateOverride).trim()
      : (document.getElementById("fxDate").value || "");

    const qs = new URLSearchParams();
    qs.set("date", date);
    qs.set("timezone", tz);
    if (leagueIds) qs.set("league_ids", leagueIds);
    return qs;
  }





  async function ensureRawLoaded() {
    const key = getFilterKey();
    if (rawFixturesMap && rawCacheKey === key) return true;

    rawFixturesMap = null;
    rawCacheKey = key;

    const tz = document.getElementById("fxTz").value || "UTC";
    const dateForRaw =
      (selectedFixture && selectedFixture.date_utc)
        ? ymdInTz(selectedFixture.date_utc, tz)
        : (document.getElementById("fxDate").value || "");

    const qs = buildFixturesQuery(dateForRaw);

    document.getElementById("rawHint").textContent = "원본(raw) 불러오는 중...";
    const r = await api(adminUrl(`/api/fixtures_raw?` + qs.toString()), { method: "GET" });

    if (r.status >= 400 || !r.data || !r.data.ok) {
      document.getElementById("rawHint").textContent = "원본(raw) 로드 실패: " + JSON.stringify(r.data);
      return false;
    }

    const rows = r.data.rows || [];
    const m = {};
    for (const x of rows) {
      m[String(x.fixture_id)] = x;
    }
    rawFixturesMap = m;
    document.getElementById("rawHint").textContent = `원본(raw) rows: ${rows.length}`;
    return true;
  }


  function diffObjects(a, b, path="", out=[]) {
    // a=raw, b=current
    const isObj = v => v && typeof v === "object" && !Array.isArray(v);
    const isArr = v => Array.isArray(v);

    if (isObj(a) && isObj(b)) {
      const keys = new Set([...Object.keys(a), ...Object.keys(b)]);
      for (const k of keys) {
        if (String(k).startsWith("_")) continue; // 내부 메타키 제외
        diffObjects(a[k], b[k], path ? (path + "." + k) : k, out);
      }
      return out;
    }

    if (isArr(a) || isArr(b)) {
      const sa = JSON.stringify(a);
      const sb = JSON.stringify(b);
      if (sa !== sb) out.push({ path, raw: a, now: b });
      return out;
    }

    // primitive / null / undefined
    if ((a ?? null) !== (b ?? null)) out.push({ path, raw: a, now: b });
    return out;
  }

  function updateComparisonViews() {
    // 현재(노출)
    document.getElementById("fxPreviewNow").textContent = JSON.stringify(selectedFixture || {}, null, 2);

    // patch는 textarea 기준
    let patchObj = null;
    try {
      patchObj = JSON.parse(document.getElementById("patch").value || "{}");
      if (!patchObj || typeof patchObj !== "object") patchObj = {};
    } catch (e) {
      patchObj = { _error: "patch JSON parse failed" };
    }
    document.getElementById("fxPreviewPatch").textContent = JSON.stringify(patchObj, null, 2);

    // raw + diff
    const raw = rawFixturesMap ? rawFixturesMap[String(selectedFixture?.fixture_id)] : null;
    document.getElementById("fxPreviewRaw").textContent = JSON.stringify(raw || {}, null, 2);

    if (raw && selectedFixture) {
      const diffs = diffObjects(raw, selectedFixture, "", []).slice(0, 200);

      const lines = diffs.map(d => {
        const a = JSON.stringify(d.raw);
        const b = JSON.stringify(d.now);
        return `${d.path}: ${a} -> ${b}`;
      });

      document.getElementById("fxPreviewDiff").textContent =
        lines.length ? lines.join("\n") : "(변경 없음)";
    } else {
      document.getElementById("fxPreviewDiff").textContent = "(비교 데이터 없음)";
    }

  }

    async function loadBundleViews() {
    if (!selectedFixture) {
      document.getElementById("bundlePreviewRaw").textContent = "{}";
      document.getElementById("bundlePreviewMerged").textContent = "{}";
      document.getElementById("bundlePreviewDiff").textContent = "[]";
      bundleRaw = null;
      bundleMerged = null;
      return;
    }

    const fx = selectedFixture.fixture_id;
    const lg = selectedFixture.league_id;
    const se = selectedFixture.season;

    if (fx == null || lg == null || se == null) {
      document.getElementById("bundlePreviewRaw").textContent = "{}";
      document.getElementById("bundlePreviewMerged").textContent = "{}";
      document.getElementById("bundlePreviewDiff").textContent = "[]";
      bundleRaw = null;
      bundleMerged = null;
      return;
    }

    const base = new URLSearchParams({
      fixture_id: String(fx),
      league_id: String(lg),
      season: String(se),
    });

    // raw (override 미적용)
    const qsRaw = new URLSearchParams(base);
    qsRaw.set("apply_override", "0");

    // merged (override 적용)
    const qsMerged = new URLSearchParams(base);
    qsMerged.set("apply_override", "1");

    // ✅ match_detail_bundle는 public endpoint이므로 publicApi 사용
    const r1 = await publicApi(adminUrl("/api/match_detail_bundle?" + qsRaw.toString()));
    const r2 = await publicApi(adminUrl("/api/match_detail_bundle?" + qsMerged.toString()));


    bundleRaw = (r1.status < 400 && r1.data && r1.data.ok) ? (r1.data.data || null) : null;
    bundleMerged = (r2.status < 400 && r2.data && r2.data.ok) ? (r2.data.data || null) : null;

    document.getElementById("bundlePreviewRaw").textContent =
      JSON.stringify(bundleRaw || { _error: "raw load failed", status: r1.status, data: r1.data }, null, 2);

    document.getElementById("bundlePreviewMerged").textContent =
      JSON.stringify(bundleMerged || { _error: "merged load failed", status: r2.status, data: r2.data }, null, 2);

    if (bundleRaw && bundleMerged) {
      const diffs = diffObjects(bundleRaw, bundleMerged, "", []).slice(0, 300);
      const lines = diffs.map(d => `${d.path}: ${JSON.stringify(d.raw)} -> ${JSON.stringify(d.now)}`);
      document.getElementById("bundlePreviewDiff").textContent =
        lines.length ? lines.join("\n") : "(변경 없음)";
    } else {
      document.getElementById("bundlePreviewDiff").textContent = "[]";
    }
    evtReloadFromBundle();
  }



  async function selectFixture(fixtureId) {
    const f = currentFixtures.find(x => String(x.fixture_id) === String(fixtureId));
    if (!f) return;

    selectedFixture = f;

    // ✅ 앱처럼: 오른쪽에 “선택 경기 요약” 먼저 갱신
    renderSelectedSummary(f);

    renderFixtures();

    document.getElementById("fixtureId").value = String(f.fixture_id);
    fillQuickEditFromFixture(f);

    setStatusLine(`선택: fixture_id=${f.fixture_id}`);

    // override 조회(그리고 patch textarea 채움)
    await getOverride();

    // raw 로드 후 비교 뷰 갱신
    const ok = await ensureRawLoaded();
    if (!ok) {
      rawFixturesMap = rawFixturesMap || null;
    }
    updateComparisonViews();
    // ⚠️ loadBundleViews()는 getOverride()에서 처리 (중복 호출 방지)
  }



  async function loadFixtures() {
    // ✅ 일반 날짜 조회로 들어오면 OVR 모드 OFF
    setOverrideMode(false);

    const from = (document.getElementById("fxDate")?.value || "").trim();
    const to = (document.getElementById("fxDateTo")?.value || "").trim();

    if (!from) {
      alert("Date (From)를 선택하세요");
      return;
    }

    // ✅ from~to 범위(최대 31일) 지원 — OVR과 동일 로직
    const range = enumerateYmdRange(from, to || from, 31);
    if (!range.ok) {
      setStatusLine("");
      alert("기간 설정 오류: " + range.error + "\n\n(최대 31일까지만 지원)");
      return;
    }

    const days = range.days || [];

    setStatusLine(`fixtures 기간 조회중... (0/${days.length})`);

    // ✅ fixture_id 기준으로 dedupe (여러 날짜 합치기)
    const map = {}; // fixture_id -> row

    for (let i = 0; i < days.length; i++) {
      const day = days[i];
      setStatusLine(`fixtures 기간 조회중... (${i + 1}/${days.length}) ${day}`);

      const qs = buildFixturesQuery(day);

      // ✅ 관리자용 merged(override 반영 + hidden 포함) 사용
      const r = await api(adminUrl(`/api/fixtures_merged?` + qs.toString()), { method: "GET" });

      if (r.status >= 400 || !r.data || !r.data.ok) {
        setStatusLine("");
        alert(`fixtures_merged 로드 실패 (${day}): ` + JSON.stringify(r.data));
        return;
      }

      const rows = r.data.rows || [];
      for (const x of rows) {
        if (!x) continue;
        map[String(x.fixture_id)] = x;
      }
    }

    currentFixtures = Object.values(map);

    // ✅ NEW: 날짜로 로드된 목록 기준으로 league 드롭다운 갱신
    fxRefreshLeaguePick();

    // 선택 유지(저장/삭제 후 재선택을 위해)
    const keepId = selectedFixture ? String(selectedFixture.fixture_id) : "";
    selectedFixture = null;
    renderSelectedSummary(null);

    // raw 캐시 무효화(필터 변경될 수 있으니)
    rawFixturesMap = null;
    rawCacheKey = "";

    document.getElementById("fxPreviewNow").textContent = "{}";
    document.getElementById("fxPreviewRaw").textContent = "{}";
    document.getElementById("fxPreviewPatch").textContent = "{}";
    document.getElementById("fxPreviewDiff").textContent = "[]";
    document.getElementById("rawHint").textContent = "";

    // ✅ bundle 프리뷰도 초기화(선택이 해제되었는데 이전 데이터가 남는 문제 방지)
    document.getElementById("bundlePreviewRaw").textContent = "{}";
    document.getElementById("bundlePreviewMerged").textContent = "{}";
    document.getElementById("bundlePreviewDiff").textContent = "[]";
    bundleRaw = null;
    bundleMerged = null;

    setStatusLine("");
    renderFixtures();

    // ✅ 가능하면 이전 선택 재선택
    if (keepId) {
      const exists = currentFixtures.find(x => String(x.fixture_id) === keepId);
      if (exists) await selectFixture(keepId);
    }

    showTab("now");
  }



  async function loadOverridesOnly() {
    // ✅ 토글: 이미 OVR 모드면 일반 날짜 조회로 복귀
    if (overrideOnlyMode) {
      setOverrideMode(false);
      return loadFixtures();
    }

    setOverrideMode(true);

    const from = document.getElementById("fxDate").value;
    const to = (document.getElementById("fxDateTo")?.value || "").trim();

    if (!from) {
      alert("Date (From)를 선택하세요");
      setOverrideMode(false);
      return;
    }

    const range = enumerateYmdRange(from, to || from, 31);
    if (!range.ok) {
      setStatusLine("");
      alert("기간 설정 오류: " + range.error + "\n\n(최대 31일까지만 지원)");
      setOverrideMode(false);
      return;
    }

    const days = range.days;

    setStatusLine(`OVR 기간 조회중... (0/${days.length})`);

    const map = {}; // fixture_id -> row (dedupe)

    for (let i=0; i<days.length; i++) {
      const day = days[i];
      setStatusLine(`OVR 기간 조회중... (${i+1}/${days.length}) ${day}`);

      const qs = buildFixturesQuery(day);
      const r = await api(adminUrl(`/api/fixtures_merged?` + qs.toString()), { method: "GET" });

      if (r.status >= 400 || !r.data || !r.data.ok) {
        setStatusLine("");
        alert(`fixtures_merged 로드 실패 (${day}): ` + JSON.stringify(r.data));
        setOverrideMode(false);
        return;
      }

      const rows = r.data.rows || [];
      for (const x of rows) {
        if (!x) continue;
        if (x._has_override !== true) continue;
        map[String(x.fixture_id)] = x;
      }
    }

    currentFixtures = Object.values(map);

    // ✅ NEW: OVR 목록 기준으로도 league 드롭다운 갱신
    fxRefreshLeaguePick();

    // 선택 초기화
    selectedFixture = null;
    renderSelectedSummary(null);

    // raw 캐시 무효화
    rawFixturesMap = null;
    rawCacheKey = "";

    document.getElementById("fxPreviewNow").textContent = "{}";
    document.getElementById("fxPreviewRaw").textContent = "{}";
    document.getElementById("fxPreviewPatch").textContent = "{}";
    document.getElementById("fxPreviewDiff").textContent = "[]";
    document.getElementById("rawHint").textContent = "";

    document.getElementById("bundlePreviewRaw").textContent = "{}";
    document.getElementById("bundlePreviewMerged").textContent = "{}";
    document.getElementById("bundlePreviewDiff").textContent = "[]";
    bundleRaw = null;
    bundleMerged = null;

    setStatusLine("");
    renderFixtures();
    showTab("now");
  }







  async function getOverride() {
    const id = document.getElementById("fixtureId").value.trim();
    if (!id) return setOv("fixture_id가 필요합니다", false);

    const r = await api(adminUrl(`/api/overrides/${id}`), { method: "GET" });
    if (r.status < 400 && r.data) {
      const p = r.data.patch;
      if (p && typeof p === "object") {
        document.getElementById("patch").value = JSON.stringify(p, null, 2);
        setOv(`override 존재 · status=${r.status}`, true);
      } else {
        document.getElementById("patch").value = "{}";
        setOv(`override 없음 · status=${r.status}`, true);
      }

      updateComparisonViews();
      await loadBundleViews();
    } else {
      setOv(`status=${r.status} · ${JSON.stringify(r.data)}`, false);
      await loadBundleViews();
    }
  }

  async function upsertOverride() {
    const id = document.getElementById("fixtureId").value.trim();
    if (!id) return setOv("fixture_id가 필요합니다", false);

    applyQuickEditToPatch({ silent: true, onlyIfChanged: true });
    // evtApplyToPatch(true);  // ✅ 제거: 저장 직전에 Event Editor 내용으로 patch를 강제 덮어쓰지 않음



    let patch = null;
    try {
      patch = JSON.parse(document.getElementById("patch").value || "{}");
      if (!patch || typeof patch !== "object" || Array.isArray(patch)) patch = {};
    } catch (e) {
      return setOv("Patch JSON 파싱 실패", false);
    }

    // ✅ 변경이 없으면 저장 막기(빈 patch로 override 만들어서 OVR 생기는 문제 방지)
    if (Object.keys(patch).length === 0) {
      return setOv("변경사항이 없습니다. (Patch JSON이 비어있어서 저장하지 않았습니다)", false);
    }

    const ok = confirm("저장(Upsert)할까요? (override가 즉시 적용됩니다)");
    if (!ok) return;

    const r = await api(adminUrl(`/api/overrides/${id}`), {
      method: "PUT",
      body: JSON.stringify(patch),
    });
    setOv(`status=${r.status} · ${JSON.stringify(r.data)}`, r.status < 400);

    if (r.status < 400) {
      // 저장 후 현재 목록 새로고침(노출 결과 갱신)
      await loadFixtures();
    }
  }


  async function deleteOverride() {
    const id = document.getElementById("fixtureId").value.trim();
    if (!id) return setOv("fixture_id가 필요합니다", false);

    const ok = confirm("삭제(원복)할까요? (override가 제거되고 원본으로 돌아갑니다)");
    if (!ok) return;

    const r = await api(adminUrl(`/api/overrides/${id}`), { method: "DELETE" });
    setOv(`status=${r.status} · ${JSON.stringify(r.data)}`, r.status < 400);

    if (r.status < 400) {
      document.getElementById("patch").value = "";
      updateComparisonViews();
      await loadFixtures();
    }
  }

    // ✅ 프리셋 select → input 값 자동 반영(기존 JS는 input(id=qeStatusGroup/qeStatus)만 읽으므로 안전)
  (function(){
    const sgPreset = document.getElementById("qeStatusGroupPreset");
    const stPreset = document.getElementById("qeStatusPreset");
    const sgInput  = document.getElementById("qeStatusGroup");
    const stInput  = document.getElementById("qeStatus");

    if (sgPreset && sgInput) {
      sgPreset.addEventListener("change", () => { sgInput.value = sgPreset.value || ""; });
    }
    if (stPreset && stInput) {
      stPreset.addEventListener("change", () => { stInput.value = stPreset.value || ""; });
    }

    const up = (el) => {
      if (!el) return;
      el.addEventListener("blur", () => { el.value = String(el.value || "").trim().toUpperCase(); });
    };
    up(sgInput);
    up(stInput);
  })();


  function applyQuickEditToPatch(opts = {}) {
    const silent = (opts && opts.silent === true);
    const onlyIfChanged = (opts && opts.onlyIfChanged === true);

    const id = document.getElementById("fixtureId").value.trim();
    if (!id) {
      if (!silent) setOv("fixture_id가 필요합니다", false);
      return false;
    }

    // selectedFixture(현재 노출/override 반영 상태) 기준으로 "변경된 항목만" patch에 넣는다
    const cur = selectedFixture || {};

    const normStr = (x) => (x == null ? "" : String(x)).trim();
    const normUpper = (x) => {
      const s = normStr(x);
      return s === "" ? "" : s.toUpperCase();
    };

    const sameStr = (a, b) => normStr(a) === normStr(b);
    const sameUpper = (a, b) => normUpper(a) === normUpper(b);

    const normNum = (x) => {
      const s = String(x ?? "").trim();
      if (s === "") return null;
      const n = Number(s);
      return Number.isFinite(n) ? n : null;
    };
    const sameNum = (a, b) => (a ?? null) === (b ?? null);

    let basePatch = {};
    try {
      basePatch = JSON.parse(document.getElementById("patch").value || "{}");
      if (!basePatch || typeof basePatch !== "object" || Array.isArray(basePatch)) basePatch = {};
    } catch (e) {
      basePatch = {};
    }

    const p = {};

    const v  = normStr(document.getElementById("qeVenue").value);
    const r  = normStr(document.getElementById("qeRound").value);
    const sl = normStr(document.getElementById("qeStatusLong").value);
    const el = normNum(document.getElementById("qeElapsed").value);

    // ✅ StatusGroup/Status는 blur 이벤트에 의존하지 말고 여기서 안전하게 대문자 정규화
    const sg = normUpper(document.getElementById("qeStatusGroup").value);
    const st = normUpper(document.getElementById("qeStatus").value);

    if (!sameStr(v,  cur.venue_name))   p["venue_name"] = v;
    if (!sameStr(r,  cur.league_round)) p["league_round"] = r;
    if (!sameStr(sl, cur.status_long))  p["status_long"] = sl;
    if (!sameNum(el, cur.elapsed))      p["elapsed"] = el;

    // ✅ 비교도 대문자 기준으로 수행(대소문자 차이로 쓸데없는 diff/patch 방지)
    if (!sameUpper(sg, cur.status_group)) p["status_group"] = sg;
    if (!sameUpper(st, cur.status))       p["status"] = st;

    const hft = normNum(document.getElementById("qeHomeFt").value);
    const aft = normNum(document.getElementById("qeAwayFt").value);
    const hht = normNum(document.getElementById("qeHomeHt").value);
    const aht = normNum(document.getElementById("qeAwayHt").value);

    const homeCur = cur.home || {};
    const awayCur = cur.away || {};

    let homePatch = null;
    let awayPatch = null;

    if (!sameNum(hft, homeCur.ft)) { homePatch = homePatch || {}; homePatch["ft"] = hft; }
    if (!sameNum(hht, homeCur.ht)) { homePatch = homePatch || {}; homePatch["ht"] = hht; }
    if (!sameNum(aft, awayCur.ft)) { awayPatch = awayPatch || {}; awayPatch["ft"] = aft; }
    if (!sameNum(aht, awayCur.ht)) { awayPatch = awayPatch || {}; awayPatch["ht"] = aht; }

    if (homePatch) p["home"] = deepMerge(p["home"] || {}, homePatch);
    if (awayPatch) p["away"] = deepMerge(p["away"] || {}, awayPatch);

    if (!basePatch.fixture_id) basePatch.fixture_id = Number(id);

    const hasAny = Object.keys(p).length > 0;
    if (!hasAny && onlyIfChanged) {
      if (!silent) setOv("Quick Edit 변경사항이 없습니다.", true);
      return false;
    }

    const merged = deepMerge(basePatch, p);
    document.getElementById("patch").value = JSON.stringify(merged, null, 2);

    if (!silent) setOv("Quick Edit 값을 Patch JSON에 반영했습니다(아직 저장 전).", true);

    updateComparisonViews();
    return true;
  }



  // ─────────────────────────────────────
  // Event Editor (Goals/Cards/Subs) - bundle에서 이벤트 배열 경로 자동 탐지 후 배열 통째로 override
  // ─────────────────────────────────────

  let evtState = {
    path: "",        // 선택된 이벤트 배열 경로 (예: "timeline.events" 같은 형태)
    candidates: [],  // {path, score, sample}
    events: [],      // 편집 중인 이벤트 배열(원본 객체 유지)
  };

  function isObj(v){ return v && typeof v === "object" && !Array.isArray(v); }

  function deepClone(v) {
    try { return JSON.parse(JSON.stringify(v)); } catch (e) { return v; }
  }

  function getByPath(obj, path) {
    if (!obj || !path) return undefined;
    const parts = String(path).split(".").filter(Boolean);
    let cur = obj;
    for (const p of parts) {
      if (!cur) return undefined;
      cur = cur[p];
    }
    return cur;
  }

  function setByPath(obj, path, value) {
    const parts = String(path).split(".").filter(Boolean);
    if (!parts.length) return obj;
    let cur = obj;
    for (let i=0;i<parts.length;i++) {
      const k = parts[i];
      const last = (i === parts.length-1);
      if (last) {
        cur[k] = value;
      } else {
        if (!isObj(cur[k])) cur[k] = {};
        cur = cur[k];
      }
    }
    return obj;
  }

  function evtScoreArray(arr) {
    // 이벤트 배열 후보인지 점수화(휴리스틱)
    if (!Array.isArray(arr) || arr.length < 1) return 0;

    let score = 0;
    const n = Math.min(arr.length, 30);
    for (let i=0;i<n;i++) {
      const e = arr[i];
      if (!isObj(e)) continue;

      const keys = Object.keys(e);
      const hasType = keys.some(k => ["type","event_type","kind","detail","name"].includes(k));
      const hasTime = keys.some(k => ["time","minute","min","elapsed","elapsed_min","elapsedMinute"].includes(k));
      const hasTeam = keys.some(k => ["team","team_id","teamId","side"].includes(k));

      // ✅ timeline 스키마(line1/line2 등)도 player 힌트로 인정
      const hasPlayer = keys.some(k => ["player","player_name","playerName","assist","sub_in","sub_out","line1","line2"].includes(k));

      // ✅ timeline 전용 키가 있으면 후보일 확률이 높아서 가산점
      const hasTimelineKeys = keys.some(k => ["minute_label","minute_extra","side_home","snapshot_score","id_stable"].includes(k));

      if (hasType) score += 2;
      if (hasTime) score += 3;
      if (hasTeam) score += 1;
      if (hasPlayer) score += 1;
      if (hasTimelineKeys) score += 2;
    }
    // 길이가 너무 길면(배당/통계 배열 등) 오탐 방지용 가산/감산
    if (arr.length >= 5) score += 2;
    if (arr.length > 200) score -= 3;
    return score;
  }


  function evtFindCandidates(root) {
    const out = [];
    const seen = new Set();
    const stack = [{ obj: root, path: "" }];

    while (stack.length) {
      const { obj, path } = stack.pop();
      if (!obj) continue;

      if (Array.isArray(obj)) {
        const sc = evtScoreArray(obj);

        // ✅ (root_array) 후보는 UI에 노출하지 않음
        // 이유: upsertOverride()가 patch JSON을 object만 허용(배열은 저장 실패) → 불일치/혼란 방지
        if (sc >= 8 && path) {
          const p = path;
          if (!seen.has(p)) {
            seen.add(p);
            out.push({
              path: p,
              score: sc,
              sample: obj.slice(0, 2),
              len: obj.length,
            });
          }
        }

        // 배열 내부도 탐색(객체면)
        for (let i=0;i<Math.min(obj.length, 30);i++) {
          const v = obj[i];
          if (isObj(v) || Array.isArray(v)) stack.push({ obj: v, path: path }); // path 유지
        }
        continue;
      }

      if (isObj(obj)) {
        for (const k of Object.keys(obj)) {
          const v = obj[k];
          const p2 = path ? (path + "." + k) : k;
          if (isObj(v) || Array.isArray(v)) stack.push({ obj: v, path: p2 });
        }
      }
    }

    out.sort((a,b) => b.score - a.score);
    return out.slice(0, 12);
  }


  function evtRefreshPathSelect() {
    const sel = document.getElementById("evtPath");
    const hint = document.getElementById("evtHint");
    sel.innerHTML = "";

    const cands = evtState.candidates || [];
    if (!cands.length) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "(이벤트 배열을 자동 탐지하지 못했습니다. Patch JSON에 수동으로 넣어야 할 수 있어요)";
      sel.appendChild(opt);
      evtState.path = "";
      hint.textContent = "bundle 구조에서 이벤트 배열 후보를 못 찾음";
      return;
    }

    for (const c of cands) {
      const opt = document.createElement("option");
      opt.value = c.path;
      opt.textContent = `${c.path} (len=${c.len}, score=${c.score})`;
      sel.appendChild(opt);
    }

    // 기존 선택 유지 시도
    const keep = evtState.path && cands.find(x => x.path === evtState.path);
    evtState.path = keep ? evtState.path : cands[0].path;
    sel.value = evtState.path;

    hint.textContent = "가장 점수 높은 후보가 자동 선택됩니다. 맞는 경로가 아니면 드롭다운에서 바꾸세요.";

    sel.onchange = () => {
      evtState.path = sel.value || "";
      evtLoadFromBundleCurrent(); // 경로 바꾸면 해당 경로의 이벤트를 다시 로드
    };
  }

  function evtNormalizeForUi(e) {
  // 다양한 스키마를 UI 공통 필드로 매핑(최대한 안전하게)
  const o = isObj(e) ? e : {};
  const pick = (...ks) => {
    for (const k of ks) if (o[k] !== undefined && o[k] !== null) return o[k];
    return "";
  };

  const rawType = String(pick("type","event_type","kind","name") || "").toUpperCase();
  const minute = pick("minute","min","elapsed","elapsed_min","elapsedMinute");
  const extra = pick("minute_extra","extra","stoppage","added","extra_time");

  const team = pick("side","team","team_id","teamId","team_key","teamSide");

  const main = pick("line1","player","player_name","playerName","main","scorer","sub_in");
  const extraMain = pick("line2","assist","assist_name","assistName","sub_out","second_player");

  const detail = pick("detail","comment","reason","note","event_detail");
  const detailStr = String(detail || "").toLowerCase();

  // ✅ UI 타입 결정:
  // - raw가 이미 PENALTY/OWN_GOAL이면 그대로
  // - raw가 GOAL인데 detail에 penalty/own goal 힌트가 있으면 UI에서 PENALTY/OWN_GOAL로 표시
  let uiType = rawType || "OTHER";
  if (uiType === "GOAL") {
    const isPen =
      detailStr.includes("pen") ||
      detailStr.includes("pk") ||
      detailStr.includes("penalty");
    const isOg =
      detailStr.includes("own goal") ||
      detailStr.includes("og") ||
      detailStr.includes("자책");
    if (isPen) uiType = "PENALTY";
    else if (isOg) uiType = "OWN_GOAL";
  }

  const toNumOrBlank = (v) => {
    if (v === "" || v === null || v === undefined) return "";
    const n = Number(v);
    return Number.isFinite(n) ? n : "";
  };

  return {
    _raw: o,
    ui_min: toNumOrBlank(minute),
    ui_extra: toNumOrBlank(extra),
    ui_team: String(team || "").toLowerCase(),
    ui_type: uiType || "OTHER",
    ui_main: String(main || ""),
    ui_extraMain: String(extraMain || ""),
    ui_detail: String(detail || ""),
  };
}



  function evtApplyUiToRaw(row) {

  // UI 필드를 원본 객체에 최대한 무해하게 반영(없던 키는 "event_admin" 네임스페이스로 보관)
  const r = row._raw || {};
  if (!isObj(r)) return row;

  const setPref = (keys, val) => {
    for (const k of keys) {
      if (r[k] !== undefined) { r[k] = val; return true; }
    }
    return false;
  };

  // minute/extra
  const minVal = (row.ui_min === "" || row.ui_min === null || row.ui_min === undefined) ? null : Number(row.ui_min);
  const exVal  = (row.ui_extra === "" || row.ui_extra === null || row.ui_extra === undefined) ? null : Number(row.ui_extra);

  if (!setPref(["minute","min","elapsed","elapsed_min","elapsedMinute"], minVal)) {
    r.event_admin = r.event_admin || {};
    r.event_admin.minute = minVal;
  }
  if (!setPref(["minute_extra","extra","stoppage","added","extra_time"], exVal)) {
    r.event_admin = r.event_admin || {};
    r.event_admin.extra = exVal;
  }

  if (r["minute_label"] !== undefined) {
    const m = (minVal == null ? null : Number(minVal));
    const e = (exVal == null ? null : Number(exVal));
    r["minute_label"] = (m == null) ? "" : (e == null ? `${m}’` : `${m}’+${e}`);
  }

  // ✅ type: UI에서 PENALTY/OWN_GOAL 선택해도 raw는 최대한 안전하게 GOAL로 저장
  let uiType = String(row.ui_type || "OTHER").toUpperCase();
  let storeType = uiType;
  let forcedDetail = null;

  if (uiType === "PENALTY") {
    storeType = "GOAL";
    forcedDetail = "Penalty";
  } else if (uiType === "OWN_GOAL") {
    storeType = "GOAL";
    forcedDetail = "Own Goal";
  }

  if (!setPref(["type","event_type","kind","name"], storeType)) {
    r.event_admin = r.event_admin || {};
    r.event_admin.type = storeType;
  }

  // team/side (+ side_home 동기화)
  const sideVal = String(row.ui_team || "");
  if (!setPref(["side","team","team_key","teamSide"], sideVal)) {
    r.event_admin = r.event_admin || {};
    r.event_admin.team = sideVal;
  }
  if (r["side_home"] !== undefined) {
    r["side_home"] = (String(sideVal).toLowerCase() === "home");
  }

  // main/assist
  if (!setPref(["line1","player","player_name","playerName","main","scorer","sub_in"], row.ui_main)) {
    r.event_admin = r.event_admin || {};
    r.event_admin.main = row.ui_main;
  }
  if (!setPref(["line2","assist","assist_name","assistName","sub_out","second_player"], row.ui_extraMain)) {
    r.event_admin = r.event_admin || {};
    r.event_admin.extraMain = row.ui_extraMain;
  }

  // detail
  let detailVal = String(row.ui_detail || "");
  if ((detailVal.trim() === "") && forcedDetail) detailVal = forcedDetail;

  if (!setPref(["detail","comment","reason","note","event_detail"], detailVal)) {
    r.event_admin = r.event_admin || {};
    r.event_admin.detail = detailVal;
  }

  // ✅ UI 서브타입은 event_admin.subtype로도 보관(있으면 디버깅 편함)
  if (uiType === "PENALTY" || uiType === "OWN_GOAL") {
    r.event_admin = r.event_admin || {};
    r.event_admin.subtype = uiType;
  }

  return row;
}


  function evtRender() {
    const body = document.getElementById("evtBody");
    body.innerHTML = "";

    const rows = evtState.events || [];
    for (let i=0;i<rows.length;i++) {
      const row = rows[i];
      const tr = document.createElement("tr");

      tr.innerHTML = `
        <td><input type="number" value="${row.ui_min ?? ""}" data-k="ui_min" style="width:70px;"></td>
        <td><input type="number" value="${row.ui_extra ?? ""}" data-k="ui_extra" style="width:70px;"></td>
        <td>
          <select data-k="ui_team">
            <option value="" ${row.ui_team===""?"selected":""}>(none)</option>
            <option value="home" ${row.ui_team==="home"?"selected":""}>home</option>
            <option value="away" ${row.ui_team==="away"?"selected":""}>away</option>
          </select>
        </td>
        <td>
          <select data-k="ui_type">
            <option value="GOAL" ${row.ui_type==="GOAL"?"selected":""}>GOAL</option>
            <option value="PENALTY" ${row.ui_type==="PENALTY"?"selected":""}>PENALTY</option>
            <option value="OWN_GOAL" ${row.ui_type==="OWN_GOAL"?"selected":""}>OWN_GOAL</option>
            <option value="RED" ${row.ui_type==="RED"?"selected":""}>RED</option>
            <option value="YELLOW" ${row.ui_type==="YELLOW"?"selected":""}>YELLOW</option>
            <option value="SUB" ${row.ui_type==="SUB"?"selected":""}>SUB</option>
            <option value="OTHER" ${row.ui_type==="OTHER"?"selected":""}>OTHER</option>
          </select>

        </td>
        <td><input value="${escapeAttr(row.ui_main || "")}" data-k="ui_main" placeholder="main" style="width:100%;"></td>
        <td><input value="${escapeAttr(row.ui_extraMain || "")}" data-k="ui_extraMain" placeholder="assist/sub out" style="width:100%;"></td>
        <td><input value="${escapeAttr(row.ui_detail || "")}" data-k="ui_detail" placeholder="detail" style="width:100%;"></td>

        <td><button class="btnsm danger" data-act="del">삭제</button></td>
      `;


      // onchange: state 갱신 + patch 반영
      tr.querySelectorAll("input,select").forEach(el => {
        el.onchange = () => {
            const k = el.getAttribute("data-k");
            if (!k) return;

            if (k === "ui_min") row.ui_min = (el.value === "" ? "" : Number(el.value));
            else if (k === "ui_extra") row.ui_extra = (el.value === "" ? "" : Number(el.value)); // ✅ 추가
            else if (k === "ui_team") row.ui_team = String(el.value || "");
            else if (k === "ui_type") row.ui_type = String(el.value || "OTHER");
            else if (k === "ui_main") row.ui_main = String(el.value || "");
            else if (k === "ui_extraMain") row.ui_extraMain = String(el.value || "");
            else if (k === "ui_detail") row.ui_detail = String(el.value || "");

            evtApplyUiToRaw(row);
            evtApplyToPatch(true);
          };
        });


      tr.querySelector('[data-act="del"]').onclick = () => {
        evtState.events.splice(i, 1);
        evtApplyToPatch(true);
        evtRender();
      };

      body.appendChild(tr);
    }
  }

  function evtLoadFromBundleCurrent() {
    const hint = document.getElementById("evtHint");
    const src = bundleMerged || bundleRaw;
    if (!src) {
      hint.textContent = "bundle 데이터가 없습니다. (왼쪽에서 경기 선택 후 bundle 탭이 로드되어야 함)";
      evtState.events = [];
      evtRender();
      return;
    }

    const path = evtState.path || "";
    if (!path) {
      hint.textContent = "이벤트 배열 경로가 비어있습니다. 후보 선택을 확인하세요.";
      evtState.events = [];
      evtRender();
      return;
    }

    // ✅ root_array 지원: bundle 자체가 배열인 경우 로드 허용
    let arr = null;
    if (path === "(root_array)") {
      if (Array.isArray(src)) {
        arr = src;
      } else {
        hint.textContent = "선택 경로가 (root_array)이지만 bundle root가 배열이 아닙니다.";
        evtState.events = [];
        evtRender();
        return;
      }
    } else {
      arr = getByPath(src, path);
      if (!Array.isArray(arr)) {
        hint.textContent = `선택한 경로에 배열이 없습니다: ${path}`;
        evtState.events = [];
        evtRender();
        return;
      }
    }


    // UI row로 변환
    evtState.events = arr.map(e => evtNormalizeForUi(e));
    hint.textContent = `로드됨: ${path} (len=${arr.length})`;
    evtRender();
  }

  function evtReloadFromBundle() {
    evtState.candidates = evtFindCandidates(bundleMerged || bundleRaw);
    evtRefreshPathSelect();
    evtLoadFromBundleCurrent();
  }

  function evtSort() {
    evtState.events.sort((a,b) => {
      const am = (a.ui_min === "" ? 9999 : Number(a.ui_min));
      const bm = (b.ui_min === "" ? 9999 : Number(b.ui_min));
      if (am !== bm) return am - bm;
      const ae = (a.ui_extra === "" ? 0 : Number(a.ui_extra));
      const be = (b.ui_extra === "" ? 0 : Number(b.ui_extra));
      return ae - be;
    });
    evtApplyToPatch(true);
    evtRender();
  }

  function evtAdd() {
  const min = document.getElementById("evtMin").value;
  const ex = document.getElementById("evtExtra").value;
  const team = document.getElementById("evtTeam").value;
  const type = document.getElementById("evtType").value;
  const main = document.getElementById("evtPlayer").value;
  const extraMain = document.getElementById("evtAssist").value;
  const detail = document.getElementById("evtDetail").value;

  const p = (evtState.path || "").toLowerCase();
  const pLast = p.split(".").filter(Boolean).pop() || "";

  // ✅ UI type(PENALTY/OWN_GOAL)는 raw에선 안전하게 GOAL + detail로 저장
  const uiType = String(type || "OTHER").toUpperCase();
  let storeType = uiType;
  let forcedDetail = null;

  if (uiType === "PENALTY") {
    storeType = "GOAL";
    forcedDetail = "Penalty";
  } else if (uiType === "OWN_GOAL") {
    storeType = "GOAL";
    forcedDetail = "Own Goal";
  }

  let raw = null;

  if (pLast === "timeline") {
    const m = (min === "" ? null : Number(min));
    const e = (ex === "" ? null : Number(ex));
    const side = String(team || "");

    const minuteLabel =
      (m == null) ? "" : (e == null ? `${m}’` : `${m}’+${e}`);

    const finalDetail =
      (String(detail || "").trim() === "" && forcedDetail) ? forcedDetail : (String(detail || "").trim() === "" ? null : String(detail || ""));

    raw = {
      id_stable: `admin-${Date.now()}`,
      line1: String(main || ""),
      line2: (String(extraMain || "").trim() === "" ? null : String(extraMain || "")),
      minute: m,
      minute_extra: e,
      minute_label: minuteLabel,
      period: "",
      side: side,
      side_home: (side === "home"),
      snapshot_score: null,
      type: String(storeType || "OTHER"),
      detail: finalDetail,
      event_admin: (uiType === "PENALTY" || uiType === "OWN_GOAL") ? { subtype: uiType } : undefined,
    };

    // event_admin가 undefined면 제거(깔끔)
    if (raw.event_admin === undefined) delete raw.event_admin;

  } else {
    raw = {
      event_admin: {
        minute: min === "" ? null : Number(min),
        extra: ex === "" ? null : Number(ex),
        team,
        type: storeType,
        subtype: (uiType === "PENALTY" || uiType === "OWN_GOAL") ? uiType : null,
        main,
        extraMain,
        detail: (String(detail || "").trim() === "" && forcedDetail) ? forcedDetail : detail,
      }
    };
  }

  const row = evtNormalizeForUi(raw);
  row.ui_min = (min === "" ? "" : Number(min));
  row.ui_extra = (ex === "" ? "" : Number(ex));
  row.ui_team = String(team || "");
  row.ui_type = uiType;
  row.ui_main = String(main || "");
  row.ui_extraMain = String(extraMain || "");
  row.ui_detail = (String(detail || "").trim() === "" && forcedDetail) ? forcedDetail : String(detail || "");

  evtApplyUiToRaw(row);

  evtState.events.push(row);
  evtSort();

  document.getElementById("evtPlayer").value = "";
  document.getElementById("evtAssist").value = "";
  document.getElementById("evtDetail").value = "";
}


  function evtClearAll() {
    const ok = confirm("이벤트를 전부 삭제할까요? (해당 배열을 빈 배열로 override)");
    if (!ok) return;
    evtState.events = [];
    evtApplyToPatch(false);
    evtRender();
  }

  function evtApplyToPatch(silent=true) {
    // 현재 evtState.events를 patch JSON에 "선택된 경로"로 세팅
    const path = evtState.path || "";
    if (!path || path === "(root_array)") {
      if (!silent) setOv("이벤트 배열 경로가 비어있습니다. (자동 탐지/선택 확인)", false);
      return false;
    }

    let basePatch = {};
    try {
      basePatch = JSON.parse(document.getElementById("patch").value || "{}");
      if (!basePatch || typeof basePatch !== "object" || Array.isArray(basePatch)) basePatch = {};
    } catch (e) {
      basePatch = {};
    }

    const arr = evtState.events.map(r => r._raw || {});
    // 배열은 통째로 replace
    setByPath(basePatch, path, arr);

    document.getElementById("patch").value = JSON.stringify(basePatch, null, 2);
    if (!silent) setOv(`이벤트를 Patch에 반영했습니다: ${path} (len=${arr.length})`, true);

    updateComparisonViews();
    return true;
  }



  async function hideFixture() {
    let basePatch = {};
    try {
      basePatch = JSON.parse(document.getElementById("patch").value || "{}");
      if (!basePatch || typeof basePatch !== "object" || Array.isArray(basePatch)) basePatch = {};
    } catch (e) {
      basePatch = {};
    }

    basePatch.hidden = true; // 또는 false
    document.getElementById("patch").value = JSON.stringify(basePatch, null, 2);

    setOv("hidden=true 패치를 세팅했습니다. 저장(Upsert) 누르면 적용됩니다.", true);
    updateComparisonViews();
  }


  async function unhideFixture() {
    let basePatch = {};
    try {
      basePatch = JSON.parse(document.getElementById("patch").value || "{}");
      if (!basePatch || typeof basePatch !== "object" || Array.isArray(basePatch)) basePatch = {};
    } catch (e) {
      basePatch = {};
    }

    basePatch.hidden = false;
    document.getElementById("patch").value = JSON.stringify(basePatch, null, 2);

    setOv("hidden=false 패치를 세팅했습니다. 저장(Upsert) 누르면 적용됩니다.", true);
    updateComparisonViews();
  }


  document.getElementById("fxDate").value = isoDateLocal();
  const fxDateTo = document.getElementById("fxDateTo");
  if (fxDateTo) fxDateTo.value = document.getElementById("fxDate").value;
  document.getElementById("fxTz").value = "Asia/Seoul";

    // ✅ NEW: From 날짜가 To보다 이후로 바뀌면, To를 From과 동일하게 자동 보정
  (function attachFxDateClamp(){
    const fxFrom = document.getElementById("fxDate");
    const fxTo   = document.getElementById("fxDateTo");
    if (!fxFrom || !fxTo) return;

    const clamp = () => {
      const a = String(fxFrom.value || "").trim();
      const b = String(fxTo.value || "").trim();
      if (!a || !b) return;

      // YYYY-MM-DD 문자열 비교로 OK
      if (a > b) {
        fxTo.value = a;
      }
    };

    fxFrom.addEventListener("change", clamp);
    fxFrom.addEventListener("input", clamp); // 일부 브라우저/UX에서 즉시 반영
  })();



  // ✅ 필터/검색 즉시 반영 (서버 재호출 없이 UI 리스트만 갱신)
  (function attachFxLiveFilters(){
    const fxSearch = document.getElementById("fxSearch");
    const fxLeague = document.getElementById("fxLeagueIds");
    const fxTz = document.getElementById("fxTz");

    if (fxSearch) fxSearch.addEventListener("input", () => renderFixtures());
    if (fxLeague) fxLeague.addEventListener("input", () => renderFixtures());
    if (fxTz) fxTz.addEventListener("change", () => renderFixtures());

    // league_ids 입력값은 blur 시 정규화해서 “서버 쿼리도 안정화”
    if (fxLeague) fxLeague.addEventListener("blur", () => {
      fxLeague.value = normalizeLeagueIdsInput(fxLeague.value || "");
      renderFixtures();
    });
  })();


  loadFixtures();
</script>
  
  

  <script>
(function(){
  const themeKey = "SSX_ADMIN_THEME";

  function resolveInitialTheme() {
    const saved = localStorage.getItem(themeKey);
    if (saved === "light" || saved === "dark") return saved;
    const prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    return prefersDark ? "dark" : "light";
  }

  function applyTheme(theme) {
    document.documentElement.dataset.theme = theme;
  }

  applyTheme(resolveInitialTheme());

  window.addEventListener("message", (ev) => {
    const d = ev.data || {};
    if (d && d.type === "ssx_theme" && (d.theme === "light" || d.theme === "dark")) {
      localStorage.setItem(themeKey, d.theme);
      applyTheme(d.theme);
    }
  });
})();
</script>

</body>
</html>
